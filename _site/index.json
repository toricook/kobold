{
  "Kobold.Documentation/docs/README.html": {
    "href": "Kobold.Documentation/docs/README.html",
    "title": "Kobold Documentation | Kobold Game Framework",
    "summary": "Kobold Documentation This directory contains the Kobold framework documentation as plain Markdown files. GitHub Pages The documentation is published via GitHub Pages at: https://toricook.github.io/Kobold/ GitHub automatically renders the Markdown files with basic styling. Structure index.md - Main documentation homepage getting-started/ - Installation and tutorials core/ - Core framework documentation monogame/ - MonoGame integration docs extensions/ - Extension libraries procedural/ - Procedural generation tools/ - Development tools guides/ - How-to guides examples/ - Code examples Adding New Pages Just create a new .md file with Markdown content. GitHub will automatically render it."
  },
  "Kobold.Documentation/docs/core/architecture.html": {
    "href": "Kobold.Documentation/docs/core/architecture.html",
    "title": "Kobold Architecture - Entity Component System | Kobold Game Framework",
    "summary": "Kobold Architecture - Entity Component System Kobold is built on the Entity Component System (ECS) architectural pattern, providing high-performance, data-oriented game development. This guide explains what ECS is, why Kobold uses it, and how it works. What is Entity Component System? ECS is an architectural pattern that separates data (Components) from logic (Systems) and treats game objects as compositions of data (Entities). The Three Pillars Entities - Unique identifiers for game objects Just an ID number (not a class or object) Created with World.Create() Lightweight and fast to create/destroy Components - Data containers (structs) Pure data, no logic Examples: Transform, Velocity, SpriteRenderer Attached to entities to give them properties Systems - Logic processors Contain all game logic Query entities with specific components Process matched entities each frame Traditional OOP vs ECS Traditional Object-Oriented: class Player : GameObject { Vector2 position; Sprite sprite; int health; void Update() { /* update logic */ } void Render() { /* render logic */ } } class Enemy : GameObject { // Duplicate code from Player... } Problems: Rigid inheritance hierarchies Code duplication Poor cache locality Difficult to extend Entity Component System: // Components (data only) struct Transform { Vector2 Position; } struct Health { int Value; } struct SpriteRenderer { ITexture Texture; } // Entities (just IDs with components) var player = World.Create( new Transform(), new Health(), new SpriteRenderer() ); var enemy = World.Create( new Transform(), new Health(), new SpriteRenderer(), new AI() ); // Systems (logic only) class MovementSystem { void Update() { // Process all entities with Transform + Velocity var query = World.Query<Transform, Velocity>(); foreach (var entity in query) { /* move */ } } } Benefits: Composition over inheritance No code duplication Excellent cache performance Easy to add/remove behaviors Kobold's ECS Implementation Kobold uses the Arch library, a high-performance ECS implementation for C#. The World The World is the ECS container that holds all entities and components. Access it via GameEngineBase.World: public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // World is automatically created by GameEngineBase var entity = World.Create(new Transform(), new Velocity()); } } Creating Entities Entities are created with World.Create() and one or more components: // Entity with single component var entity1 = World.Create(new Transform { Position = new Vector2(100, 100) }); // Entity with multiple components var entity2 = World.Create( new Transform { Position = new Vector2(200, 200) }, new Velocity { Value = new Vector2(50, 0) }, SpriteRenderer.FullTexture(texture), BoxCollider.Square(32) ); The return value is an Entity struct (from Arch) which you can store if you need to reference it later. Components Components are structs (value types) that store data. Kobold provides many built-in components: // Core components public struct Transform { public Vector2 Position; public float Rotation; // Radians public Vector2 Scale; } public struct Velocity { public Vector2 Value; // Pixels per second } // Rendering components public struct SpriteRenderer { public ITexture Texture; public Rectangle? SourceRect; public Vector2 Scale; public Color Tint; public int Layer; } Best Practices: Keep components as simple data containers No methods (except static factories and simple helpers) Use struct not class for performance Make fields public for ECS access Querying Entities Systems query entities that have specific components: // Query all entities with Transform and Velocity var query = World.Query<Transform, Velocity>(); foreach (var entity in query) { // Get component references ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); // Modify components transform.Position += velocity.Value * deltaTime; } Query Types: // 1 component World.Query<Transform>(); // 2 components World.Query<Transform, Velocity>(); // 3+ components World.Query<Transform, Velocity, SpriteRenderer>(); // With filters (entities that DON'T have a component) World.Query<Transform>().Where(e => !e.Has<Velocity>()); Adding/Removing Components Components can be added or removed from existing entities: // Add component World.Add(entity, new Velocity { Value = new Vector2(100, 0) }); // Remove component World.Remove<Velocity>(entity); // Check if has component bool hasVelocity = World.Has<Velocity>(entity); // Get component value if (World.TryGet<Transform>(entity, out var transform)) { Console.WriteLine($\"Position: {transform.Position}\"); } Destroying Entities // Immediate destruction World.Destroy(entity); // Deferred destruction (preferred in systems) World.Add(entity, new PendingDestruction()); // DestructionSystem will remove it at the end of the frame Systems Systems contain the logic that processes entities. Kobold provides many built-in systems and allows custom systems. ISystem Interface public interface ISystem { void Update(float deltaTime, World world); } Example System public class GravitySystem : ISystem { private readonly Vector2 _gravity; public GravitySystem(Vector2 gravity) { _gravity = gravity; } public void Update(float deltaTime, World world) { var query = world.Query<Velocity, Physics>(); foreach (var entity in query) { ref var velocity = ref entity.Get<Velocity>(); ref var physics = ref entity.Get<Physics>(); if (!physics.IsStatic) { velocity.Value += _gravity * physics.Mass * deltaTime; } } } } Adding Systems Systems are added in Initialize() with an execution order: protected override void Initialize() { base.Initialize(); // Lower order = runs first Systems.AddSystem(new InputSystem(InputManager), 0, true); Systems.AddSystem(new PhysicsSystem(), 100, true); Systems.AddSystem(new CollisionSystem(), 300, true); // Render systems (called separately during Render) Systems.AddRenderSystem(new RenderSystem(Renderer)); } The third parameter (requiresGameplayState) determines if the system should pause when the game is paused. System Execution Order Kobold defines standard execution order constants: public static class SystemOrder { public const int INPUT = 0; public const int PHYSICS = 100; public const int AI = 200; public const int COLLISION = 300; public const int GAME_LOGIC = 400; public const int UI = 500; public const int CLEANUP = 600; } Use these to ensure consistent system ordering. Data-Oriented Design Benefits ECS provides several performance advantages: Cache Locality Components are stored in contiguous memory arrays (archetypes in Arch), improving CPU cache hit rates: Traditional OOP: [Player object] -> scattered memory locations [Enemy object] -> different memory locations ECS: [Transform, Transform, Transform, ...] -> contiguous array [Velocity, Velocity, Velocity, ...] -> contiguous array Parallel Processing Systems can process entity queries in parallel since components are independent: // Future Kobold feature (Arch supports this) World.Query<Transform, Velocity>().ForEach((ref Transform t, ref Velocity v) => { t.Position += v.Value * deltaTime; }).Run(); // Parallel execution No Virtual Calls Components are structs and systems query concrete types - no virtual method overhead. Composition Over Inheritance ECS makes it trivial to compose complex behaviors from simple components: // Flying enemy World.Create( new Transform(), new Velocity(), new AI { Type = AIType.Chase }, new SpriteRenderer(), new Health { Value = 3 } ); // Walking enemy (just add gravity) World.Create( new Transform(), new Velocity(), new AI { Type = AIType.Patrol }, new SpriteRenderer(), new Health { Value = 5 }, new Physics { Mass = 1.0f } // PhysicsSystem will apply gravity ); // Invincible flying enemy (remove Health) World.Create( new Transform(), new Velocity(), new AI { Type = AIType.Boss }, new SpriteRenderer() // No Health component = can't be damaged ); No inheritance hierarchies needed! Best Practices 1. Keep Components Small // Good - focused components struct Transform { Vector2 Position; float Rotation; } struct Velocity { Vector2 Value; } // Bad - kitchen sink component struct GameObject { Vector2 Position; Vector2 Velocity; Sprite Sprite; int Health; } 2. Use Tags for Categorization struct PlayerControlled { } // Empty tag component struct Enemy { } // Query only player entities var query = World.Query<Transform, PlayerControlled>(); 3. Favor Queries Over Entity References // Good - data-oriented var players = World.Query<Transform, PlayerControlled>(); foreach (var player in players) { /* ... */ } // Okay for specific relationships Entity _followTarget; // Camera follows this entity 4. System Order Matters Always add systems in logical order: Input AI/Game Logic Physics Collision Destruction Rendering 5. Use Deferred Destruction // During system update - don't destroy immediately World.Add(entity, new PendingDestruction()); // DestructionSystem cleans up at the end of the frame Advanced Topics Singleton Components For global game state, create a singleton entity: var gameState = World.Create(new GameState { Score = 0, Lives = 3 }); // Access anywhere var query = World.Query<GameState>(); ref var state = ref query.First().Get<GameState>(); state.Score += 100; Entity Relationships For parent-child or other relationships: struct Parent { public Entity Value; } struct Child { public Entity ParentEntity; } // Create parent var parent = World.Create(new Transform()); // Create children World.Create( new Transform(), new Child { ParentEntity = parent } ); Component Pools Arch automatically pools component arrays for performance. You don't need to manage this. Platform Abstraction One of Kobold's key design principles is complete separation between game logic and platform-specific code. This is achieved through interface-based abstractions. Core is Platform-Agnostic Kobold.Core has zero dependencies on MonoGame, Unity, or any rendering engine. All platform-specific functionality is defined as interfaces: // From Kobold.Core - just interfaces public interface ITexture { int Width { get; } int Height { get; } } public interface IRenderer { void DrawTexture(ITexture texture, Vector2 position, ...); void Clear(Color color); } public interface IInputManager { bool IsKeyDown(Keys key); Vector2 MousePosition { get; } } Your game logic works entirely with these abstractions, never touching MonoGame types directly. MonoGame Implementation Kobold.Monogame implements these interfaces using MonoGame: // MonoGame-specific implementation public class MonoGameTexture : ITexture { private readonly Texture2D _texture; // MonoGame type public int Width => _texture.Width; public int Height => _texture.Height; } public class MonoGameRenderer : IRenderer { private readonly SpriteBatch _spriteBatch; // MonoGame type public void DrawTexture(ITexture texture, Vector2 position, ...) { var mgTexture = ((MonoGameTexture)texture)._texture; _spriteBatch.Draw(mgTexture, position, ...); } } Why This Matters This architecture provides several benefits: 1. Alternative Platform Hosts You could theoretically implement Kobold hosts for: Custom rendering engines (Raylib, FNA, SDL2) Other game engines (Unity, potentially with adapters) Headless servers (for game logic testing or multiplayer servers) 2. Clean Code Boundaries Your game logic lives in the ECS layer and knows nothing about rendering: // Game logic - platform agnostic public class PlayerMovementSystem : ISystem { public void Update(float deltaTime, World world) { var query = world.Query<Transform, Velocity, PlayerControlled>(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); transform.Position += velocity.Value * deltaTime; // No MonoGame types here! } } } 3. Testability You can test game logic without initializing a graphics device: [Test] public void PlayerMovement_UpdatesPosition() { var world = World.Create(); var player = world.Create( new Transform { Position = Vector2.Zero }, new Velocity { Value = new Vector2(100, 0) } ); var system = new PlayerMovementSystem(); system.Update(1.0f, world); // No rendering needed var transform = world.Get<Transform>(player); Assert.AreEqual(new Vector2(100, 0), transform.Position); } 4. Future Flexibility If MonoGame development stalls or new platforms emerge, the framework can adapt without rewriting game code. Current Recommendation While the architecture supports alternative hosts, Kobold.Monogame is the recommended and best-supported implementation. It's thoroughly tested, well-integrated, and provides the best developer experience. Custom platform hosts are possible but require implementing all the platform interfaces (IRenderer, ITexture, IInputManager, etc.) and thorough testing. Learn More Game Engine - How GameEngineBase manages the World Components Reference - All built-in components Systems Reference - All built-in systems MonoGame Integration - How the MonoGame host works Arch Library - The underlying ECS library Next: Learn about GameEngineBase and the game lifecycle →"
  },
  "Kobold.Documentation/docs/core/asset-manager.html": {
    "href": "Kobold.Documentation/docs/core/asset-manager.html",
    "title": "Asset Manager - Loading and Managing Assets | Kobold Game Framework",
    "summary": "Asset Manager - Loading and Managing Assets The AssetManager class handles loading, caching, and managing textures and sprite sheets in Kobold. It's accessible via GameEngineBase.Assets. Overview AssetManager provides: Automatic texture caching (loads each texture only once) Sprite sheet support with JSON configuration files Preloading for loading screens Memory management (unload unused assets) Loading Textures LoadTexture() Loads a texture from file. Automatically caches so subsequent loads return the same instance. ITexture LoadTexture(string path) Example: protected override void Initialize() { base.Initialize(); // Load texture (relative to content root) var playerTexture = Assets.LoadTexture(\"player.png\"); // Create entity with texture World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FullTexture(playerTexture) ); // Load again - returns cached instance (fast!) var sameTexture = Assets.LoadTexture(\"player.png\"); } Caching: Once loaded, textures stay in memory until explicitly unloaded. Loading the same path multiple times returns the cached texture. GetTexture() Gets a previously loaded texture without loading from disk. ITexture? GetTexture(string path) Returns null if the texture hasn't been loaded yet. Example: var texture = Assets.GetTexture(\"player.png\"); if (texture != null) { // Texture is already loaded } IsTextureLoaded() Checks if a texture is in the cache. bool IsTextureLoaded(string path) Example: if (!Assets.IsTextureLoaded(\"enemy.png\")) { Assets.LoadTexture(\"enemy.png\"); } Sprite Sheets Sprite sheets pack multiple sprites into a single texture, improving performance and simplifying asset management. SpriteSheet JSON Format Kobold uses JSON files to define sprite sheet layouts: { \"texture\": \"characters.png\", \"spriteWidth\": 32, \"spriteHeight\": 32, \"columns\": 8, \"rows\": 4, \"spacing\": 0, \"margin\": 0, \"namedRegions\": { \"player_idle\": { \"x\": 0, \"y\": 0, \"width\": 32, \"height\": 32 }, \"player_walk_1\": { \"x\": 32, \"y\": 0, \"width\": 32, \"height\": 32 }, \"player_walk_2\": { \"x\": 64, \"y\": 0, \"width\": 32, \"height\": 32 } }, \"animations\": { \"walk\": { \"frames\": [1, 2, 3, 2], \"frameDuration\": 0.1, \"loop\": true }, \"idle\": { \"frames\": [0], \"frameDuration\": 0.5, \"loop\": true } } } LoadSpriteSheet() Loads a sprite sheet configuration and the associated texture. SpriteSheet LoadSpriteSheet(string path) Example: // Load sprite sheet var spriteSheet = Assets.LoadSpriteSheet(\"characters.json\"); var texture = Assets.LoadTexture(\"characters.png\"); // Get a specific frame Rectangle frame0 = spriteSheet.GetFrame(0); Rectangle frame5 = spriteSheet.GetFrame(5); // Get by row/column Rectangle topLeft = spriteSheet.GetFrameByRowCol(row: 0, col: 0); // Get named region Rectangle playerIdle = spriteSheet.GetNamedRegion(\"player_idle\"); // Create entity with sprite World.Create( new Transform { Position = new Vector2(200, 200) }, SpriteRenderer.FromSpriteSheet(texture, frame0) ); SpriteSheet Methods GetFrame(index) - Get frame by index (left-to-right, top-to-bottom) Rectangle GetFrame(int index) GetFrameByRowCol(row, col) - Get frame by grid position Rectangle GetFrameByRowCol(int row, int col) GetNamedRegion(name) - Get frame by name Rectangle GetNamedRegion(string name) GetAnimationFrames(animationName) - Get all frames for an animation Rectangle[] GetAnimationFrames(string animationName) CreateAnimationClip(animationName) - Create AnimationClip from config AnimationClip CreateAnimationClip(string animationName) CreateAllAnimations() - Create all animations as dictionary Dictionary<string, AnimationClip> CreateAllAnimations() Animation Example var spriteSheet = Assets.LoadSpriteSheet(\"player.json\"); var texture = Assets.LoadTexture(\"player.png\"); // Create all animations from sprite sheet var animation = new Animation { Clips = spriteSheet.CreateAllAnimations() }; animation.Play(\"idle\"); World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FromSpriteSheet(texture, spriteSheet.GetFrame(0)), animation ); Preloading Preload textures during a loading screen to avoid hitches during gameplay. PreloadTextures() Loads multiple textures at once. void PreloadTextures(params string[] paths) Example: protected override void Initialize() { base.Initialize(); // Preload all game textures Assets.PreloadTextures( \"player.png\", \"enemy1.png\", \"enemy2.png\", \"projectile.png\", \"background.png\" ); // Now all textures are cached and ready to use var player = Assets.GetTexture(\"player.png\"); // Instant! } Unloading Free memory by unloading unused textures. UnloadTexture() Unloads a specific texture from the cache. bool UnloadTexture(string path) Returns true if the texture was unloaded, false if it wasn't loaded. Example: // Unload unused boss texture after boss fight Assets.UnloadTexture(\"boss.png\"); UnloadAll() Unloads all textures from the cache. void UnloadAll() Example: // When transitioning between levels Assets.UnloadAll(); // Then load new level's assets Assets.PreloadTextures(\"level2_bg.png\", \"level2_tiles.png\"); Content Root The content root is set by the IContentLoader implementation (usually via MonoGameFileContentLoader). // MonoGameFileContentLoader sets this var loader = new MonoGameFileContentLoader(graphicsDevice, \"Content\"); // Content root directory All asset paths are relative to this root: // Loads from \"Content/player.png\" Assets.LoadTexture(\"player.png\"); // Loads from \"Content/sprites/enemy.png\" Assets.LoadTexture(\"sprites/enemy.png\"); Best Practices 1. Preload During Initialize protected override void Initialize() { base.Initialize(); // Load all assets upfront Assets.PreloadTextures( \"player.png\", \"enemy.png\", \"background.png\" ); // Create entities after assets are loaded var playerTexture = Assets.GetTexture(\"player.png\"); // ... } 2. Organize Assets in Folders Content/ ├── characters/ │ ├── player.png │ └── enemies.png ├── environment/ │ ├── tiles.png │ └── background.png └── ui/ └── icons.png Assets.LoadTexture(\"characters/player.png\"); Assets.LoadTexture(\"environment/tiles.png\"); 3. Use Sprite Sheets for Related Sprites Instead of: Content/ ├── player_idle.png ├── player_walk1.png ├── player_walk2.png ├── player_jump.png └── ... Use a single sprite sheet: Content/ ├── player.png (single texture with all frames) └── player.json (sprite sheet config) Benefits: Fewer texture loads Better GPU performance (fewer texture switches) Easier to manage animations 4. Unload Between Levels void LoadLevel(int levelNumber) { // Clear old level assets Assets.UnloadAll(); // Load new level assets Assets.PreloadTextures($\"level{levelNumber}_bg.png\", /* ... */); } 5. Check Loaded State When Needed void SpawnEnemy() { if (!Assets.IsTextureLoaded(\"enemy.png\")) { Assets.LoadTexture(\"enemy.png\"); } var texture = Assets.GetTexture(\"enemy.png\"); // Create enemy entity... } Complete Example public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Preload all assets Assets.PreloadTextures( \"player.png\", \"enemy.png\", \"projectile.png\", \"background.png\" ); // Load sprite sheet var playerSheet = Assets.LoadSpriteSheet(\"player.json\"); var playerTexture = Assets.GetTexture(\"player.png\"); // Create player with animation var animation = new Animation { Clips = playerSheet.CreateAllAnimations() }; animation.Play(\"idle\"); World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FromSpriteSheet( playerTexture, playerSheet.GetFrame(0) ), animation, new PlayerControlled() ); // Create background var bgTexture = Assets.GetTexture(\"background.png\"); World.Create( new Transform { Position = Vector2.Zero }, SpriteRenderer.Background(bgTexture) ); } protected override void Shutdown() { // Clean up (optional - Kobold does this automatically) Assets.UnloadAll(); base.Shutdown(); } } See Also SpriteRenderer Component - Using loaded textures Animation - Sprite animation Sprite Sheet Editor - Creating sprite sheet configs Next: Learn about the Event Bus →"
  },
  "Kobold.Documentation/docs/core/components.html": {
    "href": "Kobold.Documentation/docs/core/components.html",
    "title": "Components Reference | Kobold Game Framework",
    "summary": "Components Reference Components are data structs that you attach to entities. This page documents all built-in components in Kobold.Core. Core Components Transform Position, rotation, and scale in 2D space. Every visible entity needs a Transform. Location: Kobold.Core.Components.Core.Transform public struct Transform { public Vector2 Position; // World position in pixels public float Rotation; // Rotation in radians public Vector2 Scale; // Scale multiplier (1,1 = normal size) } Methods: Translate(Vector2 delta) - Move by offset Rotate(float radians) - Rotate by angle LookAt(Vector2 target) - Point towards target ToMatrix() - Get transformation matrix Properties: Forward - Direction vector (based on rotation) Right - Right vector (perpendicular to forward) Example: var entity = World.Create( new Transform { Position = new Vector2(400, 300), Rotation = 0, Scale = new Vector2(1, 1) } ); // Rotate to face right ref var transform = ref entity.Get<Transform>(); transform.LookAt(new Vector2(500, 300)); Velocity Movement vector in pixels per second. Location: Kobold.Core.Components.Physics.Velocity public struct Velocity { public Vector2 Value; // Pixels per second } Properties: Speed - Magnitude of velocity Direction - Normalized direction vector IsMoving - True if speed > 0 Methods: SetDirectionAndSpeed(Vector2 direction, float speed) Add(Vector2 delta) - Add to velocity ClampToMaxSpeed(float maxSpeed) - Limit speed Static Factories: FromDirectionAndSpeed(Vector2 direction, float speed) FromAngleAndSpeed(float radians, float speed) Example: World.Create( new Transform { Position = new Vector2(100, 100) }, new Velocity { Value = new Vector2(150, 0) } // Move right at 150 px/s ); // Or use factory var velocity = Velocity.FromAngleAndSpeed(MathF.PI / 4, 200); // 45°, 200 px/s Physics Physical properties for physics simulation. Location: Kobold.Core.Components.Physics.Physics public struct Physics { public float Mass; // kg (affects gravity) public float Restitution; // Bounciness (0-1) public float Damping; // Velocity decay (0-1) public bool IsStatic; // Immovable object } Example: // Bouncy ball World.Create( new Transform { Position = new Vector2(400, 100) }, new Velocity { Value = Vector2.Zero }, new Physics { Mass = 1.0f, Restitution = 0.9f, // Very bouncy Damping = 0.99f // Minimal air resistance } ); BoxCollider Axis-Aligned Bounding Box (AABB) collision shape. Location: Kobold.Core.Components.Physics.BoxCollider public struct BoxCollider { public Vector2 Size; // Width and height public Vector2 Offset; // Offset from Transform position } Methods: GetWorldPosition(Transform) - Get world-space position GetWorldBounds(Transform) - Get AABB bounds GetWorldCenter(Transform) - Get center point Contains(Vector2) - Point-in-box test Overlaps(BoxCollider, Transform, Transform) - Box-box test Static Factories: FromRenderSize(int width, int height) - Match sprite size Square(float size) - Square collider Shrunken(int width, int height, int margin) - Smaller than sprite Example: // Collider matching sprite size var texture = Assets.LoadTexture(\"player.png\"); World.Create( new Transform { Position = new Vector2(200, 200) }, SpriteRenderer.FullTexture(texture), BoxCollider.FromRenderSize(texture.Width, texture.Height) ); // Custom sized collider World.Create( new Transform { Position = new Vector2(300, 300) }, new RectangleRenderer { Size = new Vector2(64, 64), Color = Color.Blue }, BoxCollider.Square(64) ); Rendering Components SpriteRenderer Renders a texture or sprite from a sprite sheet. Location: Kobold.Core.Components.Rendering.SpriteRenderer public struct SpriteRenderer { public ITexture Texture; public Rectangle? SourceRect; // null = full texture public Vector2 Scale; public float Rotation; public Color Tint; public int Layer; public Vector2 Pivot; // Rotation/scale origin (0-1) } Static Factories: FullTexture(ITexture, scale, tint, layer) - Use entire texture FromSpriteSheet(ITexture, Rectangle sourceRect, ...) - Single sprite Background(ITexture, layer) - Background layer GameObject(ITexture, scale, layer) - Game object layer UI(ITexture, layer) - UI layer Example: var texture = Assets.LoadTexture(\"player.png\"); // Full texture World.Create( new Transform { Position = new Vector2(100, 100) }, SpriteRenderer.FullTexture(texture, scale: 2.0f) ); // From sprite sheet var spriteSheet = Assets.LoadSpriteSheet(\"characters.json\"); World.Create( new Transform { Position = new Vector2(200, 200) }, SpriteRenderer.FromSpriteSheet( texture, spriteSheet.GetFrame(0), scale: 1.5f, tint: Color.Red ) ); RectangleRenderer Renders a colored rectangle. Location: Kobold.Core.Components.Rendering.RectangleRenderer public struct RectangleRenderer { public Vector2 Size; public Color Color; public int Layer; } Example: World.Create( new Transform { Position = new Vector2(300, 300) }, new RectangleRenderer { Size = new Vector2(100, 50), Color = Color.Green, Layer = 100 } ); TextRenderer Renders text. Location: Kobold.Core.Components.Rendering.TextRenderer public struct TextRenderer { public string Text; public Color Color; public float FontSize; public int Layer; } Example: World.Create( new Transform { Position = new Vector2(10, 10) }, new TextRenderer { Text = \"Score: 0\", Color = Color.White, FontSize = 24, Layer = RenderLayers.UI } ); TriangleRenderer Renders a triangle. Location: Kobold.Core.Components.Rendering.TriangleRenderer public struct TriangleRenderer { public Vector2[] Points; // 3 points public Color Color; public int Layer; } Animation Sprite animation state. Location: Kobold.Core.Components.Rendering.Animation public struct Animation { public Dictionary<string, AnimationClip> Clips; public string CurrentClip; public int CurrentFrame; public float TimeInCurrentFrame; public bool IsPlaying; } Methods: Play(string clipName) - Start playing animation GetCurrentFrameRect() - Get current frame's source rectangle GetCurrentClip() - Get current AnimationClip Example: var spriteSheet = Assets.LoadSpriteSheet(\"player.json\"); var animation = new Animation(); animation.Clips[\"walk\"] = spriteSheet.CreateAnimationClip(\"walk\"); animation.Clips[\"idle\"] = spriteSheet.CreateAnimationClip(\"idle\"); animation.Play(\"idle\"); World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FromSpriteSheet(texture, spriteSheet.GetFrame(0)), animation ); AnimationClip Animation definition (frames, timing, looping). Location: Kobold.Core.Components.Rendering.AnimationClip public struct AnimationClip { public string Name; public Rectangle[] Frames; public float FrameDuration; public bool Loop; } Static Factories: FromSpriteSheet(SpriteSheet, string animationName) FromGrid(gridWidth, gridHeight, frameWidth, frameHeight, ...) Example: var walkClip = AnimationClip.FromGrid( gridWidth: 8, gridHeight: 1, frameWidth: 32, frameHeight: 32, startFrame: 0, frameCount: 8, frameDuration: 0.1f, loop: true ); Camera Viewport camera for scrolling/following. Location: Kobold.Core.Components.Core.Camera public struct Camera { public Vector2 Position; public float ViewportWidth; public float ViewportHeight; public float SmoothSpeed; public Vector2? MinBounds; public Vector2? MaxBounds; public Entity? FollowTarget; } Methods: WorldToScreen(Vector2) - Convert world to screen coordinates ScreenToWorld(Vector2) - Convert screen to world coordinates GetViewportBounds() - Get camera bounds rectangle SetBounds(Vector2 min, Vector2 max) - Constrain camera Example: // Camera that follows player var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600, SmoothSpeed = 5f, FollowTarget = playerEntity, MinBounds = new Vector2(0, 0), MaxBounds = new Vector2(2000, 1500) } ); Gameplay Components Tags String tags for categorizing entities. Location: Kobold.Core.Components.Core.Tags public struct Tags { public string[] Values; } Example: World.Create( new Transform { Position = new Vector2(100, 100) }, new Tags { Values = new[] { \"Enemy\", \"Flying\", \"Boss\" } } ); // Query entities with tag var enemies = World.Query<Transform, Tags>() .Where(e => { var tags = e.Get<Tags>(); return tags.Values.Contains(\"Enemy\"); }); Lifetime Automatically destroys entity after time expires. Location: Kobold.Core.Components.Gameplay.Lifetime public struct Lifetime { public float TimeRemaining; // Seconds } Example: // Particle that lives for 2 seconds World.Create( new Transform { Position = new Vector2(300, 300) }, new RectangleRenderer { Size = new Vector2(5, 5), Color = Color.Yellow }, new Lifetime { TimeRemaining = 2.0f } ); PlayerControlled Marker component for player-controlled entities. Location: Kobold.Core.Components.Gameplay.PlayerControlled public struct PlayerControlled { } Example: var player = World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FullTexture(texture), new PlayerControlled() ); // Query only player entities var players = World.Query<Transform, Velocity, PlayerControlled>(); ScreenBounds Defines screen boundaries for BoundarySystem. Location: Kobold.Core.Components.Gameplay.ScreenBounds public struct ScreenBounds { public float MinX, MaxX, MinY, MaxY; } Example: // Usually created once at game start World.Create(new ScreenBounds { MinX = 0, MaxX = 800, MinY = 0, MaxY = 600 }); GameState Global game state storage. Location: Kobold.Core.Components.Core.GameState public struct GameState { public GameStateType State; // Add your game-specific fields } public enum GameStateType { Menu, Playing, Paused, GameOver } Example: // Create singleton game state entity var gameState = World.Create(new GameState { State = GameStateType.Playing }); // Access from anywhere var query = World.Query<GameState>(); ref var state = ref query.First().Get<GameState>(); state.State = GameStateType.Paused; PendingDestruction Marks entity for removal at end of frame. Location: Kobold.Core.Components.Gameplay.PendingDestruction public struct PendingDestruction { } Example: // Mark for destruction (safer than immediate World.Destroy) World.Add(entity, new PendingDestruction()); // DestructionSystem will remove it at the end of the frame CustomBoundaryBehavior Custom screen boundary handling. Location: Kobold.Core.Components.Gameplay.CustomBoundaryBehavior public struct CustomBoundaryBehavior { public BoundaryBehavior Behavior; } public enum BoundaryBehavior { None, // Do nothing Wrap, // Wrap to opposite side Clamp, // Stop at edge Bounce, // Bounce off edge Destroy // Destroy entity } Render Layers Constants for layered rendering: public static class RenderLayers { public const int Background = 0; public const int GameObjects = 100; public const int UI = 200; public const int Debug = 300; } Lower numbers render first (behind). Collision Layers Enum for collision filtering: public enum CollisionLayer { Default = 0, Player = 1, Enemy = 2, Projectile = 3, Environment = 4, PlayerProjectile = 5, EnemyProjectile = 6, Pickup = 7, Trigger = 8 } Use with CollisionSystem and CollisionMatrix. See Also Systems - Systems that use these components Architecture - Understanding ECS Code Snippets - Component usage examples Next: Learn about Systems that process these components →"
  },
  "Kobold.Documentation/docs/core/event-bus.html": {
    "href": "Kobold.Documentation/docs/core/event-bus.html",
    "title": "Event Bus - Decoupled Event System | Kobold Game Framework",
    "summary": "Event Bus - Decoupled Event System The EventBus provides a pub/sub (publish/subscribe) event system for decoupled communication between game systems. It's accessible via GameEngineBase.Events. Overview EventBus allows systems to communicate without direct references: Publishers raise events when something happens Subscribers listen for and react to events Type-safe event handling Support for both interface-based and Action-based handlers Basic Usage 1. Define an Event Events can be any type - classes, structs, or records: // Record (recommended) public record PlayerDiedEvent(Entity Player, string Cause); // Class public class ScoreChangedEvent { public int NewScore { get; init; } public int Delta { get; init; } } // Struct public struct LevelCompletedEvent { public int LevelNumber; public float CompletionTime; } 2. Subscribe to Events Subscribe in your game's Initialize(): protected override void Initialize() { base.Initialize(); // Subscribe with Action (lambda) Events.Subscribe<PlayerDiedEvent>(e => { Console.WriteLine($\"Player died from {e.Cause}\"); }); // Subscribe with method reference Events.Subscribe<ScoreChangedEvent>(OnScoreChanged); } private void OnScoreChanged(ScoreChangedEvent e) { Console.WriteLine($\"Score: {e.NewScore} (+{e.Delta})\"); } 3. Publish Events Publish events when something happens: // In a collision handler private void OnCollision(CollisionEvent collision) { if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Enemy) { Events.Publish(new PlayerDiedEvent(collision.EntityA, \"Enemy collision\")); } } // When score changes private void AddScore(int points) { _currentScore += points; Events.Publish(new ScoreChangedEvent { NewScore = _currentScore, Delta = points }); } API Reference Subscribe Subscribe to events with an Action: void Subscribe<T>(Action<T> handler) where T : notnull Example: Events.Subscribe<PlayerDiedEvent>(e => { // Handle player death ShowGameOverScreen(); }); Subscribe with an IEventHandler: void Subscribe<T>(IEventHandler<T> handler) where T : notnull Example: public class ScoreDisplay : IEventHandler<ScoreChangedEvent> { public void Handle(ScoreChangedEvent eventData) { UpdateScoreUI(eventData.NewScore); } } // Subscribe Events.Subscribe(new ScoreDisplay()); Publish Publish an event to all subscribers: void Publish<T>(T eventData) where T : notnull Example: Events.Publish(new LevelCompletedEvent { LevelNumber = 1, CompletionTime = 45.2f }); Unsubscribe Remove a handler: void Unsubscribe<T>(Action<T> handler) where T : notnull void Unsubscribe<T>(IEventHandler<T> handler) where T : notnull Example: Action<PlayerDiedEvent> handler = e => { /* ... */ }; Events.Subscribe(handler); // Later... Events.Unsubscribe(handler); Clear Remove all subscribers: void Clear() Built-in Events CollisionEvent Published by CollisionSystem when entities collide: public record CollisionEvent { public Entity EntityA; public Entity EntityB; public Vector2 CollisionPoint; public Vector2 Normal; public float Penetration; public CollisionLayer LayerA; public CollisionLayer LayerB; } Example: Events.Subscribe<CollisionEvent>(collision => { if (collision.LayerA == CollisionLayer.Projectile && collision.LayerB == CollisionLayer.Enemy) { // Projectile hit enemy World.Destroy(collision.EntityA); World.Destroy(collision.EntityB); Events.Publish(new EnemyKilledEvent()); } }); Patterns and Examples Game State Events public record GameStateChangedEvent(GameStateType OldState, GameStateType NewState); // Publish when state changes Events.Publish(new GameStateChangedEvent(GameStateType.Playing, GameStateType.Paused)); // Subscribe to handle pausing Events.Subscribe<GameStateChangedEvent>(e => { if (e.NewState == GameStateType.Paused) { // Show pause menu } }); Achievement System public record AchievementUnlockedEvent(string AchievementId, string Name); Events.Subscribe<EnemyKilledEvent>(e => { _enemiesKilled++; if (_enemiesKilled >= 100) { Events.Publish(new AchievementUnlockedEvent(\"killer\", \"Kill 100 Enemies\")); } }); Events.Subscribe<AchievementUnlockedEvent>(e => { ShowNotification($\"Achievement Unlocked: {e.Name}\"); }); Power-up System public record PowerUpCollectedEvent(PowerUpType Type, float Duration); Events.Subscribe<CollisionEvent>(collision => { if (World.Has<PowerUp>(collision.EntityA) && World.Has<PlayerControlled>(collision.EntityB)) { var powerUp = World.Get<PowerUp>(collision.EntityA); Events.Publish(new PowerUpCollectedEvent(powerUp.Type, powerUp.Duration)); World.Destroy(collision.EntityA); } }); Events.Subscribe<PowerUpCollectedEvent>(e => { ApplyPowerUpToPlayer(e.Type, e.Duration); ShowPowerUpUI(e.Type, e.Duration); }); Best Practices 1. Use Records for Events Records provide value equality and clean syntax: // Good public record PlayerScored(int Points, Entity Player); // Less good public class PlayerScored { public int Points { get; set; } public Entity Player { get; set; } } 2. Unsubscribe When Done // One-shot event handler Action<BossDefeatedEvent> handler = null; handler = e => { ShowVictoryScreen(); Events.Unsubscribe(handler); // Unsubscribe after first call }; Events.Subscribe(handler); 3. Don't Overuse Events Events are great for cross-cutting concerns, but don't use them for everything: Good use cases: UI updates in response to game events Achievement/stat tracking Audio triggers Cross-system notifications Bad use cases: Core game loop logic (use systems instead) Tight coupling between systems (use direct queries) Performance-critical paths (events have overhead) 4. Event Naming Use past tense for events that have happened: // Good PlayerDiedEvent ScoreChangedEvent LevelCompletedEvent // Not as clear PlayerDieEvent ScoreChangeEvent LevelCompleteEvent 5. Hierarchical Events You can use inheritance for event filtering: public record GameEvent; // Base event public record PlayerEvent : GameEvent; public record EnemyEvent : GameEvent; public record PlayerDiedEvent : PlayerEvent; public record PlayerScoredEvent : PlayerEvent; // Subscribe to all player events Events.Subscribe<PlayerEvent>(e => { Console.WriteLine($\"Player event: {e.GetType().Name}\"); }); Complete Example public class SpaceShooter : GameEngineBase { private int _score = 0; private int _lives = 3; protected override void Initialize() { base.Initialize(); // Subscribe to game events Events.Subscribe<EnemyDestroyedEvent>(OnEnemyDestroyed); Events.Subscribe<PlayerHitEvent>(OnPlayerHit); Events.Subscribe<CollisionEvent>(OnCollision); // Create systems Systems.AddSystem(new CollisionSystem(CreateCollisionMatrix()), 300, true); // Create player World.Create( new Transform { Position = new Vector2(400, 500) }, SpriteRenderer.FullTexture(Assets.LoadTexture(\"player.png\")), new PlayerControlled(), BoxCollider.Square(32) ); } private void OnCollision(CollisionEvent collision) { if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Enemy) { Events.Publish(new PlayerHitEvent(collision.EntityA)); } if (collision.LayerA == CollisionLayer.Projectile && collision.LayerB == CollisionLayer.Enemy) { World.Destroy(collision.EntityA); // Destroy projectile World.Destroy(collision.EntityB); // Destroy enemy Events.Publish(new EnemyDestroyedEvent(collision.EntityB)); } } private void OnEnemyDestroyed(EnemyDestroyedEvent e) { _score += 100; Events.Publish(new ScoreChangedEvent(_score, 100)); if (_score >= 1000) { Events.Publish(new AchievementUnlockedEvent(\"score_master\", \"Reach 1000 points\")); } } private void OnPlayerHit(PlayerHitEvent e) { _lives--; Events.Publish(new LivesChangedEvent(_lives)); if (_lives <= 0) { Events.Publish(new GameOverEvent(_score)); } } } // Event definitions public record EnemyDestroyedEvent(Entity Enemy); public record PlayerHitEvent(Entity Player); public record ScoreChangedEvent(int NewScore, int Delta); public record LivesChangedEvent(int Lives); public record AchievementUnlockedEvent(string Id, string Name); public record GameOverEvent(int FinalScore); See Also Architecture - Event-driven design in ECS Systems - Using events in systems Collision System - CollisionEvent details Next: Learn about Utilities →"
  },
  "Kobold.Documentation/docs/core/game-engine.html": {
    "href": "Kobold.Documentation/docs/core/game-engine.html",
    "title": "GameEngineBase | Kobold Game Framework",
    "summary": "GameEngineBase GameEngineBase is the abstract base class that every Kobold game extends. It's an implementation of the IGameEngine, which defines the basic definition of what makes a game. A game is initialized once at the beginning and shut down once at the end, and in between, the game runs. While it runs, there is a loop. In every iteration of the loop, the state of everything that exists in the game (the \"entities\") is updated and then the current state of the game is rendered. The update loop requires knowledge of how much time has passed since the last update was called (the \"delta time\") since update loops may run at different rates on different hardware. In other words, IGameEngine is public interface IGameEngine { void Initialize(); void Update(float deltaTime); void Render(); void Shutdown(); } The base class contains singletons that all games must have. These are: World - The ECS IRenderer - Dependency injection for the thing responsible for drawing stuff to the screen IInputManager - Dependency injection for the thing responsible for reading inputs from attached hardware IContentLoader - Dependency injection for the thing responsible for getting game content (textures, sounds, etc.) AssetManager - Singleton that keeps track of all assets and handles loading and caching them EventBus - Singleton that allows publishing and subscribing to messages SystemManager - Singleton that keeps track of all systems and exposes a method to update all of them"
  },
  "Kobold.Documentation/docs/core/index.html": {
    "href": "Kobold.Documentation/docs/core/index.html",
    "title": "Core | Kobold Game Framework",
    "summary": "Kobold.Core The core library containing shared functionality that should be used in almost every game."
  },
  "Kobold.Documentation/docs/core/systems.html": {
    "href": "Kobold.Documentation/docs/core/systems.html",
    "title": "Systems Reference | Kobold Game Framework",
    "summary": "Systems Reference Systems contain the logic that processes entities with specific components each frame. This page documents all built-in systems in Kobold.Core. System Basics All systems implement ISystem or IRenderSystem: public interface ISystem { void Update(float deltaTime, World world); } public interface IRenderSystem { void Render(World world); } Systems are added in your game's Initialize() method: protected override void Initialize() { base.Initialize(); // Add update systems with execution order Systems.AddSystem(new PhysicsSystem(), order: 100, requiresGameplayState: true); Systems.AddSystem(new CollisionSystem(matrix), order: 300, requiresGameplayState: true); // Add render systems Systems.AddRenderSystem(new RenderSystem(Renderer)); } System Execution Order Use these constants for consistent ordering: public static class SystemOrder { public const int INPUT = 0; public const int PHYSICS = 100; public const int AI = 200; public const int COLLISION = 300; public const int GAME_LOGIC = 400; public const int UI = 500; public const int CLEANUP = 600; } Built-in Systems PhysicsSystem Moves entities based on velocity and applies physics simulation. Location: Kobold.Core.Systems.PhysicsSystem Processes: Entities with Transform and Velocity components Configuration: public class PhysicsConfig { public bool EnableGravity = false; public Vector2 GlobalGravity = new Vector2(0, 980); // Pixels/sec² public bool EnableDamping = false; public float GlobalDamping = 0.99f; // 0-1 } Usage: var config = new PhysicsConfig { EnableGravity = true, GlobalGravity = new Vector2(0, 500), // Platformer gravity EnableDamping = true, GlobalDamping = 0.98f }; Systems.AddSystem(new PhysicsSystem(config), SystemOrder.PHYSICS, true); What it does: Applies gravity to entities with Physics component (if enabled) Applies damping to velocity (if enabled) Moves entities: position += velocity * deltaTime Example: // Entity affected by gravity World.Create( new Transform { Position = new Vector2(400, 100) }, new Velocity { Value = Vector2.Zero }, new Physics { Mass = 1.0f, Damping = 0.99f } ); CollisionSystem Detects and resolves collisions between entities with BoxCollider. Location: Kobold.Core.Systems.CollisionSystem Processes: Entities with Transform and BoxCollider components Configuration: public class CollisionMatrix { public void SetCollision(CollisionLayer layerA, CollisionLayer layerB, bool collides); public bool ShouldCollide(CollisionLayer layerA, CollisionLayer layerB); } Usage: var matrix = new CollisionMatrix(); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Enemy, true); matrix.SetCollision(CollisionLayer.Projectile, CollisionLayer.Enemy, true); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Pickup, true); var config = new CollisionSystemConfig { EnableCollisionResponse = true, // Apply physics-based impulses EnableCollisionEvents = true // Publish CollisionEvent }; Systems.AddSystem(new CollisionSystem(matrix, config), SystemOrder.COLLISION, true); Features: AABB (box-box) collision detection Collision filtering via CollisionMatrix Optional collision response (separates overlapping entities) Publishes CollisionEvent to EventBus CollisionEvent: public record CollisionEvent { public Entity EntityA; public Entity EntityB; public Vector2 CollisionPoint; public Vector2 Normal; public float Penetration; public CollisionLayer LayerA; public CollisionLayer LayerB; } Example: // Subscribe to collisions Events.Subscribe<CollisionEvent>(OnCollision); void OnCollision(CollisionEvent collision) { if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Enemy) { // Player hit enemy World.Destroy(collision.EntityB); } } RenderSystem Draws all entities with rendering components. Location: Kobold.Core.Systems.RenderSystem Processes: Entities with Transform and rendering components (SpriteRenderer, RectangleRenderer, TextRenderer, TriangleRenderer) Usage: Systems.AddRenderSystem(new RenderSystem(Renderer)); What it does: Collects all renderable entities Sorts by layer (lower layers render first/behind) Applies camera transformation if Camera exists Calls appropriate IRenderer methods for each entity type Rendering Order: Background (layer 0) Game objects (layer 100) UI (layer 200) Debug (layer 300) Example: // Background (renders behind everything) World.Create( new Transform { Position = Vector2.Zero }, SpriteRenderer.Background(bgTexture) // Layer 0 ); // Game object (middle layer) World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.GameObject(playerTexture) // Layer 100 ); // UI (renders on top) World.Create( new Transform { Position = new Vector2(10, 10) }, new TextRenderer { Text = \"Score: 0\", Layer = RenderLayers.UI } // Layer 200 ); AnimationSystem Updates sprite animations. Location: Kobold.Core.Systems.AnimationSystem Processes: Entities with Animation and SpriteRenderer components Usage: Systems.AddSystem(new AnimationSystem(), SystemOrder.GAME_LOGIC, true); What it does: Advances animation time Changes frames when frame duration expires Loops or stops at end based on clip settings Updates SpriteRenderer.SourceRect to current frame Example: var spriteSheet = Assets.LoadSpriteSheet(\"player.json\"); var texture = Assets.LoadTexture(\"player.png\"); var animation = new Animation(); animation.Clips[\"walk\"] = spriteSheet.CreateAnimationClip(\"walk\"); animation.Clips[\"idle\"] = spriteSheet.CreateAnimationClip(\"idle\"); animation.Play(\"walk\"); World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FromSpriteSheet(texture, spriteSheet.GetFrame(0)), animation ); // Switch animations in Update() ref var anim = ref entity.Get<Animation>(); if (velocity.IsMoving) anim.Play(\"walk\"); else anim.Play(\"idle\"); BoundarySystem Handles screen boundary behavior (wrap, bounce, clamp, destroy). Location: Kobold.Core.Systems.BoundarySystem Processes: Entities with Transform (and optionally Velocity for bouncing) Usage: Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Wrap), SystemOrder.GAME_LOGIC, true); Boundary Behaviors: None - Do nothing Wrap - Wrap to opposite side (Asteroids-style) Clamp - Stop at edge Bounce - Bounce off edges (reverses velocity) Destroy - Destroy entity when it leaves screen Requires: An entity with ScreenBounds component defining the boundaries Example: // Define screen bounds World.Create(new ScreenBounds { MinX = 0, MaxX = 800, MinY = 0, MaxY = 600 }); // Wrap behavior (Asteroids-style) Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Wrap), 200, true); // Per-entity custom behavior World.Create( new Transform { Position = new Vector2(400, 300) }, new Velocity { Value = new Vector2(100, 0) }, new CustomBoundaryBehavior { Behavior = BoundaryBehavior.Bounce } ); DestructionSystem Removes entities marked with PendingDestruction. Location: Kobold.Core.Systems.DestructionSystem Processes: Entities with PendingDestruction component Usage: Systems.AddSystem(new DestructionSystem(), SystemOrder.CLEANUP, true); What it does: Destroys all entities marked with PendingDestruction Runs at the end of the frame (cleanup phase) Safer than calling World.Destroy() during system updates Example: // Mark entity for destruction World.Add(entity, new PendingDestruction()); // DestructionSystem will remove it at end of frame InputSystem Processes input and updates player-controlled entities. Location: Kobold.Core.Systems.InputSystem Processes: Custom - you typically query entities yourself Usage: Systems.AddSystem(new InputSystem(InputManager), SystemOrder.INPUT, true); Note: InputSystem is often custom per-game. You can also handle input directly in your GameEngineBase.Update() method. Example: public class PlayerInputSystem : ISystem { private readonly IInputManager _input; public PlayerInputSystem(IInputManager input) { _input = input; } public void Update(float deltaTime, World world) { var players = world.Query<Transform, Velocity, PlayerControlled>(); foreach (var player in players) { ref var velocity = ref player.Get<Velocity>(); var moveDir = Vector2.Zero; if (_input.IsKeyDown(KeyCode.W)) moveDir.Y -= 1; if (_input.IsKeyDown(KeyCode.S)) moveDir.Y += 1; if (_input.IsKeyDown(KeyCode.A)) moveDir.X -= 1; if (_input.IsKeyDown(KeyCode.D)) moveDir.X += 1; if (moveDir != Vector2.Zero) { velocity.Value = Vector2.Normalize(moveDir) * 200f; } else { velocity.Value = Vector2.Zero; } } } } GameStateSystem Manages game state transitions and pausing. Location: Kobold.Core.Systems.GameStateSystem Processes: Entities with GameState component Usage: Systems.AddSystem(new GameStateSystem(), SystemOrder.GAME_LOGIC, false); // Always runs What it does: Manages pausing/unpausing based on GameState Systems with requiresGameplayState = true pause when not in Playing state Systems with requiresGameplayState = false always run Example: // Create game state entity var gameState = World.Create(new GameState { State = GameStateType.Playing }); // Pause game ref var state = ref World.Get<GameState>(gameState); state.State = GameStateType.Paused; // Gameplay systems stop updating Creating Custom Systems Basic Custom System public class GravityWellSystem : ISystem { private readonly Vector2 _wellPosition; private readonly float _strength; public GravityWellSystem(Vector2 position, float strength) { _wellPosition = position; _strength = strength; } public void Update(float deltaTime, World world) { var query = world.Query<Transform, Velocity>(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); var direction = Vector2.Normalize(_wellPosition - transform.Position); var distance = Vector2.Distance(transform.Position, _wellPosition); if (distance > 10) // Avoid division by zero { var force = direction * (_strength / distance); velocity.Value += force * deltaTime; } } } } // Add to game Systems.AddSystem(new GravityWellSystem(new Vector2(400, 300), 10000f), 150, true); Custom Render System public class DebugColliderRenderSystem : IRenderSystem { private readonly IRenderer _renderer; public DebugColliderRenderSystem(IRenderer renderer) { _renderer = renderer; } public void Render(World world) { var query = world.Query<Transform, BoxCollider>(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var collider = ref entity.Get<BoxCollider>(); var bounds = collider.GetWorldBounds(transform); // Draw collider outline _renderer.DrawRectangle( new Vector2(bounds.Left, bounds.Top), new Vector2(bounds.Width, bounds.Height), Color.Lime ); } } } Best Practices 1. Respect System Order Always add systems in logical order: Systems.AddSystem(new InputSystem(...), SystemOrder.INPUT, true); Systems.AddSystem(new PhysicsSystem(), SystemOrder.PHYSICS, true); Systems.AddSystem(new CollisionSystem(...), SystemOrder.COLLISION, true); Systems.AddSystem(new DestructionSystem(), SystemOrder.CLEANUP, true); 2. Use requiresGameplayState Correctly true - System pauses when game is paused (gameplay systems) false - System always runs (UI, menu systems) 3. Don't Destroy During Iteration // Bad - can cause issues foreach (var entity in query) { World.Destroy(entity.Entity); // Dangerous! } // Good - mark for deferred destruction foreach (var entity in query) { World.Add(entity.Entity, new PendingDestruction()); } 4. Cache Expensive Queries public class MySystem : ISystem { private QueryDescription _query; public MySystem() { _query = new QueryDescription().WithAll<Transform, Velocity>(); } public void Update(float deltaTime, World world) { foreach (var entity in world.Query(_query)) { // Process... } } } See Also Components - Components that systems process Architecture - Understanding ECS Game Engine - Adding systems to your game Next: Learn about Asset Management →"
  },
  "Kobold.Documentation/docs/core/utilities.html": {
    "href": "Kobold.Documentation/docs/core/utilities.html",
    "title": "Utilities - Helper Functions | Kobold Game Framework",
    "summary": "Utilities - Helper Functions Kobold provides various utility classes and functions for common game development tasks. MathUtils Static utility class with math helper functions. Location: Kobold.Core.MathUtils Clamping Clamp(value, min, max) - Constrains a value within a range public static float Clamp(float value, float min, float max) public static int Clamp(int value, int min, int max) Example: // Keep player within screen bounds var x = MathUtils.Clamp(playerX, 0, 800); var y = MathUtils.Clamp(playerY, 0, 600); Random RandomRange(min, max) - Random number in range public static float RandomRange(float min, float max) public static int RandomRange(int min, int max) Example: // Spawn enemy at random X position var x = MathUtils.RandomRange(0, 800); var y = 50; RandomDirection() - Random unit vector public static Vector2 RandomDirection() Example: // Particle with random direction var direction = MathUtils.RandomDirection(); var velocity = direction * 150f; Interpolation Lerp(a, b, t) - Linear interpolation public static float Lerp(float a, float b, float t) public static Vector2 Lerp(Vector2 a, Vector2 b, float t) Example: // Smooth camera follow cameraPos = MathUtils.Lerp(cameraPos, targetPos, 0.1f * deltaTime); MoveTowards(current, target, maxDelta) - Move towards target public static float MoveTowards(float current, float target, float maxDelta) public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDelta) Example: // Move towards target at fixed speed transform.Position = MathUtils.MoveTowards( transform.Position, targetPosition, speed * deltaTime ); Angles DegreesToRadians(degrees) - Convert degrees to radians public static float DegreesToRadians(float degrees) RadiansToDegrees(radians) - Convert radians to degrees public static float RadiansToDegrees(float radians) WrapAngle(radians) - Wrap angle to -π to π range public static float WrapAngle(float radians) AngleDifference(from, to) - Shortest angle between two angles public static float AngleDifference(float from, float to) Example: // Rotate towards target var currentAngle = transform.Rotation; var targetAngle = MathF.Atan2(target.Y - pos.Y, target.X - pos.X); var angleDiff = MathUtils.AngleDifference(currentAngle, targetAngle); if (MathF.Abs(angleDiff) > 0.01f) { transform.Rotation += MathF.Sign(angleDiff) * rotSpeed * deltaTime; } EntityFactory Helper class for quickly creating common entity patterns. Location: Kobold.Core.Factories.EntityFactory CreateRectangle public Entity CreateRectangle(World world, Vector2 position, Vector2 size, Color color) Example: var rect = EntityFactory.CreateRectangle( World, new Vector2(100, 100), new Vector2(50, 50), Color.Blue ); CreateMovingRectangle public Entity CreateMovingRectangle( World world, Vector2 position, Vector2 size, Color color, Vector2 velocity ) CreateText public Entity CreateText( World world, Vector2 position, string text, Color color, float fontSize = 16 ) Example: var scoreText = EntityFactory.CreateText( World, new Vector2(10, 10), \"Score: 0\", Color.White, 24 ); Configuration Classes GameConfig Configure game window and settings. public class GameConfig { public int WindowWidth = 800; public int WindowHeight = 600; public string WindowTitle = \"Kobold Game\"; public Color BackgroundColor = Color.Black; public int TargetFPS = 60; } Example: var config = new GameConfig { WindowWidth = 1024, WindowHeight = 768, WindowTitle = \"My Game\", BackgroundColor = Color.FromArgb(255, 20, 20, 40) }; MonoGameHost.Run(new MyGame(), config); PhysicsConfig Configure physics simulation. public class PhysicsConfig { public bool EnableGravity = false; public Vector2 GlobalGravity = new Vector2(0, 980); public bool EnableDamping = false; public float GlobalDamping = 0.99f; } Example: // Platformer physics var config = new PhysicsConfig { EnableGravity = true, GlobalGravity = new Vector2(0, 500), EnableDamping = true, GlobalDamping = 0.98f }; Systems.AddSystem(new PhysicsSystem(config), 100, true); CollisionMatrix Configure which layers collide. public class CollisionMatrix { public void SetCollision(CollisionLayer a, CollisionLayer b, bool collides); public bool ShouldCollide(CollisionLayer a, CollisionLayer b); } Example: var matrix = new CollisionMatrix(); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Enemy, true); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Pickup, true); matrix.SetCollision(CollisionLayer.Projectile, CollisionLayer.Enemy, true); Systems.AddSystem(new CollisionSystem(matrix), 300, true); Extension Methods Kobold may include extension methods for common operations (check current implementation). See Also Code Snippets - Practical usage examples MathUtils in action - Using math utilities You've completed the Core documentation! Continue to MonoGame Integration →"
  },
  "Kobold.Documentation/docs/examples/code-snippets.html": {
    "href": "Kobold.Documentation/docs/examples/code-snippets.html",
    "title": "Code Snippets - Common Patterns | Kobold Game Framework",
    "summary": "Code Snippets - Common Patterns This page contains copy-paste ready code snippets for common game development patterns in Kobold. Use these as starting points for your own implementations. Table of Contents Creating Entities Movement and Physics Input Handling Collision Detection Rendering Animation Cameras Timers and Lifecycle Events Utilities Creating Entities Simple Moving Sprite var texture = Assets.LoadTexture(\"player.png\"); var player = World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FullTexture(texture), new Velocity { Value = new Vector2(100, 0) } ); Rectangle with Physics var entity = World.Create( new Transform { Position = new Vector2(100, 100) }, new RectangleRenderer { Size = new Vector2(50, 50), Color = Color.Green, Layer = 100 }, new Velocity { Value = Vector2.Zero }, new Physics { Mass = 1.0f, Damping = 0.98f, Restitution = 0.8f }, BoxCollider.Square(50) ); Sprite from Sprite Sheet var spriteSheet = Assets.LoadSpriteSheet(\"characters.json\"); var texture = Assets.LoadTexture(\"characters.png\"); var entity = World.Create( new Transform { Position = new Vector2(200, 200) }, SpriteRenderer.FromSpriteSheet( texture, spriteSheet.GetFrame(0), scale: 2.0f ) ); Entity with Animation var spriteSheet = Assets.LoadSpriteSheet(\"player.json\"); var texture = Assets.LoadTexture(\"player.png\"); var animation = new Animation(); animation.Clips[\"walk\"] = spriteSheet.CreateAnimationClip(\"walk\"); animation.Clips[\"idle\"] = spriteSheet.CreateAnimationClip(\"idle\"); animation.Play(\"idle\"); var player = World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FromSpriteSheet(texture, spriteSheet.GetFrame(0)), animation ); Movement and Physics Apply Force/Impulse // Query entities with velocity var query = World.Query<Velocity>(); foreach (var entity in query) { ref var velocity = ref entity.Get<Velocity>(); // Apply an impulse (instant velocity change) velocity.Value += new Vector2(100, -200); // Or set velocity directly velocity.Value = new Vector2(150, 0); } Continuous Movement // In your game's Update method protected override void Update(float deltaTime) { base.Update(deltaTime); var query = World.Query<Transform, Velocity>(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); transform.Position += velocity.Value * deltaTime; } } Move Towards Target var query = World.Query<Transform, Velocity>(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); var target = new Vector2(500, 300); var direction = Vector2.Normalize(target - transform.Position); var speed = 100f; velocity.Value = direction * speed; } Rotate to Face Direction ref var transform = ref entity.Get<Transform>(); ref var velocity = ref entity.Get<Velocity>(); if (velocity.IsMoving) { transform.LookAt(transform.Position + velocity.Direction); } Input Handling Basic Keyboard Input protected override void Update(float deltaTime) { base.Update(deltaTime); if (InputManager.IsKeyPressed(KeyCode.Space)) { // Fire weapon (triggered once per key press) } if (InputManager.IsKeyDown(KeyCode.W)) { // Move forward (continuous while held) } } Player Movement (8-Direction) var query = World.Query<Transform, Velocity, PlayerControlled>(); foreach (var entity in query) { ref var velocity = ref entity.Get<Velocity>(); var moveDir = Vector2.Zero; if (InputManager.IsKeyDown(KeyCode.W)) moveDir.Y -= 1; if (InputManager.IsKeyDown(KeyCode.S)) moveDir.Y += 1; if (InputManager.IsKeyDown(KeyCode.A)) moveDir.X -= 1; if (InputManager.IsKeyDown(KeyCode.D)) moveDir.X += 1; if (moveDir != Vector2.Zero) { moveDir = Vector2.Normalize(moveDir); velocity.Value = moveDir * 200f; // 200 pixels per second } else { velocity.Value = Vector2.Zero; } } Mouse Input var mousePos = InputManager.GetMousePosition(); if (InputManager.IsMouseButtonPressed(MouseButton.Left)) { // Spawn something at mouse position World.Create( new Transform { Position = mousePos }, new RectangleRenderer { Size = new Vector2(10, 10), Color = Color.Red } ); } Collision Detection Subscribe to Collision Events protected override void Initialize() { base.Initialize(); // Subscribe to collision events Events.Subscribe<CollisionEvent>(OnCollision); } private void OnCollision(CollisionEvent collision) { // Check collision layers if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Enemy) { // Player hit enemy World.Destroy(collision.EntityB); } if (collision.LayerA == CollisionLayer.Projectile && collision.LayerB == CollisionLayer.Enemy) { // Projectile hit enemy World.Destroy(collision.EntityA); // Destroy projectile World.Destroy(collision.EntityB); // Destroy enemy } } Custom Collision Response private void OnCollision(CollisionEvent collision) { // Apply knockback if (World.Has<Velocity>(collision.EntityB)) { ref var velocity = ref World.Get<Velocity>(collision.EntityB); velocity.Value += collision.Normal * 300f; // Knockback force } } Point-in-Rectangle Check var query = World.Query<Transform, BoxCollider>(); var mousePos = InputManager.GetMousePosition(); foreach (var entity in query) { ref var transform = ref entity.Get<Transform>(); ref var collider = ref entity.Get<BoxCollider>(); if (collider.Contains(mousePos)) { // Mouse is over this entity } } Rendering Layer-based Rendering // Background (renders behind) World.Create( new Transform { Position = Vector2.Zero }, SpriteRenderer.Background(backgroundTexture) ); // Game objects (middle layer) World.Create( new Transform { Position = new Vector2(100, 100) }, SpriteRenderer.GameObject(playerTexture) ); // UI (renders on top) World.Create( new Transform { Position = new Vector2(10, 10) }, new TextRenderer { Text = \"Score: 0\", Color = Color.White, FontSize = 24, Layer = RenderLayers.UI } ); Sprite with Tint and Rotation World.Create( new Transform { Position = new Vector2(200, 200), Rotation = MathF.PI / 4 }, new SpriteRenderer { Texture = texture, SourceRect = null, // Use full texture Scale = new Vector2(2, 2), Tint = Color.FromArgb(255, 255, 100, 100), // Reddish tint Layer = 100 } ); Animation Play Animation Based on State var query = World.Query<Velocity, Animation>(); foreach (var entity in query) { ref var velocity = ref entity.Get<Velocity>(); ref var animation = ref entity.Get<Animation>(); if (velocity.IsMoving) { if (animation.CurrentClip != \"walk\") animation.Play(\"walk\"); } else { if (animation.CurrentClip != \"idle\") animation.Play(\"idle\"); } } Create Animation from Grid var walkClip = AnimationClip.FromGrid( gridWidth: 8, // 8 frames wide gridHeight: 1, // 1 frame tall frameWidth: 32, frameHeight: 32, startFrame: 0, frameCount: 8, frameDuration: 0.1f, // 10 FPS loop: true ); Cameras Follow Player // Create camera entity var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600, SmoothSpeed = 5f, FollowTarget = playerEntity } ); Camera with Bounds var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600, MinBounds = new Vector2(0, 0), MaxBounds = new Vector2(2000, 1500) // Map size } ); Timers and Lifecycle Timed Destruction // Create a particle that lives for 2 seconds World.Create( new Transform { Position = new Vector2(300, 300) }, new RectangleRenderer { Size = new Vector2(5, 5), Color = Color.Yellow }, new Lifetime { TimeRemaining = 2.0f } ); Delayed Action // Custom component public struct DelayedAction { public float TimeRemaining; public Action Action; } // Usage World.Create( new DelayedAction { TimeRemaining = 3.0f, Action = () => Console.WriteLine(\"3 seconds elapsed!\") } ); // In a custom system var query = World.Query<DelayedAction>(); foreach (var entity in query) { ref var delayed = ref entity.Get<DelayedAction>(); delayed.TimeRemaining -= deltaTime; if (delayed.TimeRemaining <= 0) { delayed.Action?.Invoke(); World.Destroy(entity.Entity); } } Events Publish Custom Event // Define event public record PlayerScoredEvent(int Points, Entity Player); // Publish Events.Publish(new PlayerScoredEvent(100, playerEntity)); // Subscribe Events.Subscribe<PlayerScoredEvent>(e => { Console.WriteLine($\"Player scored {e.Points} points!\"); }); One-time Event Handler void OnGameStart() { Action<PlayerDiedEvent> handler = null; handler = (e) => { Console.WriteLine(\"Game Over!\"); Events.Unsubscribe(handler); // Unsubscribe after first call }; Events.Subscribe(handler); } Utilities Random Position in Rectangle var randomX = MathUtils.RandomRange(0, 800); var randomY = MathUtils.RandomRange(0, 600); var randomPos = new Vector2(randomX, randomY); Random Direction var randomDirection = MathUtils.RandomDirection(); var velocity = randomDirection * 150f; // Random direction, fixed speed Lerp Position ref var transform = ref entity.Get<Transform>(); var target = new Vector2(500, 300); transform.Position = MathUtils.Lerp( transform.Position, target, 0.05f // Interpolation factor (0-1) ); Clamp to Bounds ref var transform = ref entity.Get<Transform>(); transform.Position = new Vector2( MathUtils.Clamp(transform.Position.X, 0, 800), MathUtils.Clamp(transform.Position.Y, 0, 600) ); Angle Between Vectors var from = transform.Forward; var to = Vector2.Normalize(target - transform.Position); var angleDiff = MathUtils.AngleDifference( MathF.Atan2(from.Y, from.X), MathF.Atan2(to.Y, to.X) ); Complete Examples Spawning Projectiles private void FireProjectile(Vector2 position, Vector2 direction) { var projectileTexture = Assets.LoadTexture(\"bullet.png\"); World.Create( new Transform { Position = position, Rotation = MathF.Atan2(direction.Y, direction.X) }, SpriteRenderer.FullTexture(projectileTexture), new Velocity { Value = direction * 400f }, BoxCollider.FromRenderSize(projectileTexture.Width, projectileTexture.Height), new Lifetime { TimeRemaining = 5.0f }, new Tags { Values = new[] { \"Projectile\" } } ); } Power-up System // Power-up component public struct PowerUp { public PowerUpType Type; public float Duration; } // Create power-up entity World.Create( new Transform { Position = new Vector2(300, 300) }, SpriteRenderer.FullTexture(powerUpTexture), BoxCollider.Square(32), new PowerUp { Type = PowerUpType.SpeedBoost, Duration = 5.0f } ); // Collision handler private void OnCollision(CollisionEvent collision) { if (World.Has<PowerUp>(collision.EntityA) && World.Has<PlayerControlled>(collision.EntityB)) { var powerUp = World.Get<PowerUp>(collision.EntityA); ApplyPowerUp(collision.EntityB, powerUp); World.Destroy(collision.EntityA); } } Need more examples? Check out the example games: Asteroids Walkthrough Pong Walkthrough Cave Explorer Walkthrough"
  },
  "Kobold.Documentation/docs/examples/index.html": {
    "href": "Kobold.Documentation/docs/examples/index.html",
    "title": "Example Projects | Kobold Game Framework",
    "summary": "Example Projects The Kobold repository includes several complete example games demonstrating framework features. Asteroids Classic arcade space shooter. Demonstrates: Physics with rotation and thrust Collision detection Screen wrapping (BoundarySystem) Projectile systems Entity destruction Key Code: Player ship with rotation controls Asteroid splitting on collision Weapon firing system Pong Classic paddle game. Demonstrates: Simple physics (ball bouncing) Player input Collision detection Score tracking Basic AI opponent CaveExplorer Procedural cave exploration game. Demonstrates: Procedural generation (cellular automata) Tilemap rendering Tilemap collision Camera following with bounds Player movement Key Code: Cave generation with CellularAutomataGenerator Tilemap setup with collision Camera constrained to map bounds Code Snippets For quick reference patterns, see Code Snippets. Running Examples # Clone repository git clone https://github.com/toricook/Kobold.git cd Kobold # Run an example cd Asteroids dotnet run cd ../Pong dotnet run cd ../CaveExplorer dotnet run Learning Path Start with Pong - Simplest example Try Asteroids - More complex physics Explore CaveExplorer - Tilemaps and procedural generation See Also: Code Snippets for copy-paste patterns →"
  },
  "Kobold.Documentation/docs/explainers/entity-component-system.html": {
    "href": "Kobold.Documentation/docs/explainers/entity-component-system.html",
    "title": "Entity Component System (ECS) Framework | Kobold Game Framework",
    "summary": "Entity Component System (ECS) Framework What is it? There are probably a lot of explainers out there for ECS that are written better than this doc here. For me, the easiest way to understand ECS is by comparing it to the more well known Object Oriented Programming (OOP). Say you were making a dungeon crawler using OOP. You might start off by creating a class for your player character. It could look something like this: class Player { Vector2 position; Sprite sprite; int health; void Update() { /* update logic */ } void Render() { /* render logic */ } } But then when you go to make your enemies, you realize they share a lot of qualities with the player -- they also have health, a position, and a sprite. So perhaps instead you go and make a base class for both of them like this: abstract class Actor { Vector2 position; Sprite sprite; int health; void Update() { /* update logic */ } void Render() { /* render logic */ } } Then a player is just an implementation of an Actor, maybe with some additional logic to do input handling so that the real life player can control their movements. And an enemy is also an Actor, but it has some kind of AI movement logic attached. So far, so good. But then what if you want to make another kind of enemy that's invulnerable, so it has no need for a health field? Or what about one that's invisible, so it doesn't have a sprite or need a Render() method? Well, maybe an Actor shouldn't actually be renderable or have health by default -- these are separate concerns, after all. Maybe we need a new abstract base class for an Actor that can take damage, or an Actor that is also visible, or an Actor that is both. You can see how we can quickly end up with a ton of class hierarchies that are almost-but-not-quite the same and we would end up duplicating a lot of code. You may have heard of the principle of \"Composition over Inheritance\", which helps get around issues like this. Instead of an \"is-a\" relationship (a player IS An actor), you create \"has-a\" relationships (a player HAS A renderable component and HAS A health component). ECS follows this principle. But it's also not JUST a way to get composition over inheritance. ECS also uses the principle of Data Oriented Design. To understand what this priciple is, consider our player and all of our enemies in our dungeon crawler. Let's say we are also using a velocity field on each one in order to calculate whether this entity should move or not. In each frame, we have to iterate over all the entities, check their velocity, then multiply it by the time and update thier position. Then once we have the new positions, we need to iterate over all of the entities again and render them to the screen using their sprite component. But the inefficiency here comes from the bigass data object that we are iterating over each time. The system responsible for moving each entity doesn't care about the sprite, and the system responsibile for rendering (probably) doesn't care about the velocity. Yet they both need to load ALL of that data about the entity into memory just to do something with one little piece of it. This is the problem that Data Oriented Programming attempts to solve. So now we are ready to learn what ECS is. It stands for Entity Component System (though I think it's a bit clearer to write it like Entity, Component, System to make it clear that these are the 3 elements of the framework) -- all words that I used in the above explanation to help motivate the defition. In ECS, each \"thing\" that exists in your game is not an implementation of a class but an entity, which is literally just a unique ID. The things that make each entity behave in a certain way are called components -- the are the \"has-a\" objects like sprites and health. But components are always just data -- they are structs (value types). The components are acted on by systems, where each system needs access only to a certain type of component to do its job. The \"magic\" in the performance comes from the way that systems can access an array of just the components they need and then iterate over and act on those components without caring about the entities that those components are attached to. With ECS, we would write the code from the dungeon crawler example like this: struct Position { float x; float y; } struct Health { float value; } struct Sprite { ITexture texture; } and then create each entity by just creating some object that has a unique ID and the right collection of components. But before I can get into how to create the entities, and how to create the systems that actually do things with these components, I need to give a quick intro to Arch. Quick Arch Intro"
  },
  "Kobold.Documentation/docs/explainers/index.html": {
    "href": "Kobold.Documentation/docs/explainers/index.html",
    "title": "Explainers | Kobold Game Framework",
    "summary": "Explainers Docs to explain concepts (rather than documentation of specific things in the code)."
  },
  "Kobold.Documentation/docs/extensions/index.html": {
    "href": "Kobold.Documentation/docs/extensions/index.html",
    "title": "Kobold.Extensions - Optional Framework Features | Kobold Game Framework",
    "summary": "Kobold.Extensions - Optional Framework Features Kobold.Extensions provides specialized systems and components that are common in many games but not universally required. Philosophy The core Kobold framework (Kobold.Core) is intentionally minimal. Extensions provide optional features that would bloat the core but are useful for specific game types. Current Extensions Tilemaps Grid-based level design and rendering system. Use for: Platformers RPGs and roguelikes Puzzle games Top-down games Strategy games Features: Multi-layer tilemaps Tile properties (solid, animated, damage, etc.) Tilemap collision system Viewport culling for performance Integration with procedural generation Quick Example: var tileMap = new TileMap(width: 32, height: 24, tileWidth: 32, tileHeight: 32); var tileSet = TileSet.FromTexture(texture, 32, 32); // Set tiles tileMap.SetTile(layer: 0, x: 5, y: 10, tileId: 1); // Create tilemap entity World.Create(new TilemapComponent(tileMap, tileSet, texture)); // Add tilemap systems Systems.AddSystem(new TilemapSystem(), 100, true); Systems.AddSystem(new TilemapCollisionSystem(), 310, true); Future Extensions Potential future extensions (not yet implemented): Particle systems UI framework Pathfinding/navigation AI behavior trees Audio management Save/load system Installation dotnet add package Kobold.Extensions Or reference the project: <ProjectReference Include=\"..\\Kobold.Extensions\\Kobold.Extensions.csproj\" /> See Also Tilemaps Guide - Complete tilemap documentation Procedural Generation - Works great with tilemaps Next: Tilemaps - Grid-based level design →"
  },
  "Kobold.Documentation/docs/extensions/tilemaps.html": {
    "href": "Kobold.Documentation/docs/extensions/tilemaps.html",
    "title": "Tilemaps - Grid-Based Level Design | Kobold Game Framework",
    "summary": "Tilemaps - Grid-Based Level Design The Tilemaps system provides grid-based level design, rendering, and collision for 2D games. Overview TileMap - Grid data structure storing tile IDs TileSet - Tile metadata (visuals, properties, collision) TilemapComponent - ECS component attaching tilemap to entity TilemapSystem - Updates animations TilemapCollisionSystem - Handles tile-entity collision Quick Start // Create tilemap var tileMap = new TileMap( width: 32, // 32 tiles wide height: 24, // 24 tiles tall tileWidth: 32, // 32 pixels per tile tileHeight: 32, layerCount: 2 // 2 layers (background + foreground) ); // Create tileset var tileSet = TileSet.FromTexture( texturePath: \"tiles.png\", tileWidth: 32, tileHeight: 32, spacing: 0, margin: 0 ); // Configure tile properties tileSet.SetTileProperties(1, new TileProperties { IsSolid = true }); tileSet.SetTileProperties(2, new TileProperties { IsSolid = false, CollisionLayer = TileCollisionLayer.Water }); // Fill tilemap tileMap.Fill(layer: 0, x: 0, y: 0, width: 32, height: 24, tileId: 0); // Background tileMap.SetTile(layer: 1, x: 5, y: 10, tileId: 1); // Place solid tile // Create entity var texture = Assets.LoadTexture(\"tiles.png\"); World.Create(new TilemapComponent(tileMap, tileSet, texture)); // Add systems Systems.AddSystem(new TilemapSystem(), 100, true); Systems.AddSystem(new TilemapCollisionSystem(), 310, true); Systems.AddRenderSystem(new TilemapRenderSystem(Renderer)); TileMap API Constructor: TileMap(int width, int height, int tileWidth, int tileHeight, int layerCount = 1) Methods: GetTile(layer, x, y) - Get tile ID at position SetTile(layer, x, y, tileId) - Set tile at position Fill(layer, x, y, width, height, tileId) - Fill region WorldToTile(worldX, worldY) - Convert world coords to tile coords TileToWorld(tileX, tileY) - Convert tile coords to world coords GetTilesInBounds(layer, x, y, width, height) - Query tiles in region Clone() - Create a copy TileSet API Factory: TileSet.FromTexture(texturePath, tileWidth, tileHeight, spacing, margin) Methods: SetTileProperties(tileId, properties) - Configure tile behavior GetTileProperties(tileId) - Query tile properties IsSolid(tileId) - Quick solid check GetTileSourceRect(tileId, tilesPerRow) - Calculate sprite sheet position SetTileRange(startId, count, properties) - Configure multiple tiles TileProperties public struct TileProperties { public bool IsSolid; // Blocks movement public TileCollisionLayer CollisionLayer; // Collision type public float Friction; // Movement resistance public int Damage; // Harm to entities public string Type; // Custom identifier public bool IsAnimated; // Animated tile public int[] AnimationFrames; // Frame tile IDs public float AnimationSpeed; // Frames per second public Dictionary<string, object> CustomProperties; // Game-specific data } CollisionLayers: Solid - Blocks all movement Platform - One-way platform (land from above) Trigger - Passes through, publishes event Water - Special behavior Ice - Low friction Ladder - Climbable Tilemap Collision TilemapCollisionSystem handles entity-tile collision: // Automatically resolves collisions with solid tiles // Publishes events for triggers Events.Subscribe<TileTriggerEvent>(e => { Console.WriteLine($\"Entity {e.Entity} entered trigger tile at {e.TileX}, {e.TileY}\"); }); Events.Subscribe<TileDamageEvent>(e => { // Entity took damage from tile }); Complete Example See CaveExplorer game for a complete tilemap + procedural generation example. See Also Procedural Generation - Generate tilemaps procedurally Collision System - Entity collision Next: Procedural Generation →"
  },
  "Kobold.Documentation/docs/getting-started/index.html": {
    "href": "Kobold.Documentation/docs/getting-started/index.html",
    "title": "Getting Started with Kobold | Kobold Game Framework",
    "summary": "Getting Started with Kobold Welcome to Kobold! This guide will help you install the framework, understand the basics, and build your first game. What is Kobold? Kobold is a 2D game framework built on the Entity Component System (ECS) architecture and MonoGame. It provides: High-performance ECS using the Arch library Built-in physics and collision systems Sprite rendering and animation Asset management and sprite sheet support Event-driven architecture Platform abstraction layer Prerequisites Before you start, make sure you have: .NET 8 SDK or later - Download here MonoGame - Installed via NuGet (handled automatically) A code editor - Visual Studio, VS Code, or Rider Basic C# knowledge - Familiarity with C# syntax and OOP concepts Quick Navigation Choose your path: Installation Set up Kobold and create your first project. Start here if you're brand new to Kobold. Quick Start A 5-minute tutorial that gets you up and running with a minimal working example. Perfect if you learn by doing. Your First Game Build a complete simple game from scratch. Learn the fundamentals through a hands-on tutorial. Installation Overview Kobold is distributed as NuGet packages: # Core framework (required) dotnet add package Kobold.Core # MonoGame integration (required for rendering) dotnet add package Kobold.Monogame # Optional extensions dotnet add package Kobold.Extensions # Tilemaps and more dotnet add package Kobold.Procedural # Procedural generation Or reference the projects directly if working from source: <ItemGroup> <ProjectReference Include=\"..\\Kobold\\Kobold.csproj\" /> <ProjectReference Include=\"..\\Kobold.Monogame\\Kobold.Monogame.csproj\" /> </ItemGroup> Your First Kobold Game Here's the minimal code to create a Kobold game: using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using Kobold.Monogame; using System.Numerics; using System.Drawing; public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Create a simple rectangle entity World.Create( new Transform { Position = new Vector2(400, 300) }, new RectangleRenderer { Size = new Vector2(50, 50), Color = Color.Green } ); // Add the render system Systems.AddRenderSystem(new RenderSystem(Renderer)); } } // Program.cs MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My First Kobold Game\" }); This creates a window with a green square in the center. Simple! Key Concepts Entity Component System (ECS) Kobold uses ECS architecture where: Entities are just IDs (created with World.Create()) Components are data structs (like Transform, Velocity) Systems contain logic (like PhysicsSystem, RenderSystem) This separation makes games performant, modular, and easy to reason about. Game Lifecycle Every Kobold game extends GameEngineBase and follows this lifecycle: Initialize() - Set up your game, create initial entities, add systems Update(deltaTime) - Called every frame, updates all systems Render() - Called every frame, renders all entities Shutdown() - Clean up resources when the game closes The World The World property is your ECS world from the Arch library. Use it to: Create entities: World.Create(component1, component2, ...) Query entities: World.Query(...) Destroy entities: World.Destroy(entity) Systems Systems update entities each frame. Add them in Initialize(): // Update systems (called during Update) Systems.AddSystem(new PhysicsSystem(), order: 100, requiresGameplayState: true); // Render systems (called during Render) Systems.AddRenderSystem(new RenderSystem(Renderer)); Next Steps Installation - Detailed installation guide Quick Start - 5-minute hands-on tutorial Your First Game - Build a complete game Core Architecture - Deep dive into ECS Need Help? Check the examples for common patterns Review the core documentation for API reference See example games: Asteroids, Pong, CaveExplorer Ready to install? Continue to Installation →"
  },
  "Kobold.Documentation/docs/getting-started/installation.html": {
    "href": "Kobold.Documentation/docs/getting-started/installation.html",
    "title": "Installation Guide | Kobold Game Framework",
    "summary": "Installation Guide Detailed guide for installing Kobold and setting up your development environment. Prerequisites Before installing Kobold, ensure you have: .NET 8 SDK Download: https://dotnet.microsoft.com/download Verify installation: dotnet --version # Should show 8.0.x or later IDE (Choose One) Visual Studio 2022 - Full-featured IDE (Windows/Mac) Visual Studio Code - Lightweight, cross-platform JetBrains Rider - Premium cross-platform IDE MonoGame (Installed Automatically via NuGet) MonoGame.Framework.DesktopGL will be installed when you add the Kobold.Monogame package. Installation Methods Method 1: NuGet Packages (Recommended) Use this method for: Creating new games Production projects When you don't need Kobold source code # Create new project dotnet new console -n MyKoboldGame cd MyKoboldGame # Add Kobold packages dotnet add package Kobold.Core dotnet add package Kobold.Monogame dotnet add package MonoGame.Framework.DesktopGL # Optional packages dotnet add package Kobold.Extensions # For tilemaps dotnet add package Kobold.Procedural # For procedural generation Method 2: Source Code (For Development) Use this method for: Contributing to Kobold Modifying the framework Learning how Kobold works # Clone repository git clone https://github.com/toricook/Kobold.git cd Kobold # Create your game project dotnet new console -n MyGame cd MyGame # Reference Kobold projects # Edit MyGame.csproj and add: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> </PropertyGroup> <ItemGroup> <ProjectReference Include=\"..\\Kobold\\Kobold.csproj\" /> <ProjectReference Include=\"..\\Kobold.Monogame\\Kobold.Monogame.csproj\" /> </ItemGroup> </Project> Project Setup 1. Create Game Class Create MyGame.cs: using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using System.Numerics; public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Your game initialization here Systems.AddRenderSystem(new RenderSystem(Renderer)); } } 2. Create Entry Point Edit Program.cs: using Kobold.Monogame; using Kobold.Core.Configuration; using System.Drawing; MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My Kobold Game\", BackgroundColor = Color.Black }); 3. Add Content Directory mkdir Content Place PNG files in Content/ directory. 4. Configure Content Copying Edit your .csproj to copy content files: <ItemGroup> <Content Include=\"Content\\**\\*\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </Content> </ItemGroup> 5. Run Your Game dotnet run Verify Installation Create a simple test to verify everything works: using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using Kobold.Monogame; using System.Numerics; using System.Drawing; public class TestGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Create a green square World.Create( new Transform { Position = new Vector2(400, 300) }, new RectangleRenderer { Size = new Vector2(50, 50), Color = Color.Green } ); Systems.AddRenderSystem(new RenderSystem(Renderer)); } } MonoGameHost.Run(new TestGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"Kobold Test\" }); If you see a window with a green square, installation is successful! Troubleshooting \"Could not load file or assembly 'MonoGame.Framework'\" Solution: Install MonoGame.Framework.DesktopGL dotnet add package MonoGame.Framework.DesktopGL \".NET 8.0 SDK not found\" Solution: Download and install from https://dotnet.microsoft.com/download \"Window doesn't appear\" Solutions: Verify OutputType is Exe in .csproj Ensure you're calling MonoGameHost.Run() in Program.cs Check for exceptions in console output Content files not found Solutions: Verify PNG files are in Content/ directory Check .csproj has content copying configured Ensure file paths match exactly (case-sensitive on Linux/macOS) Next Steps Now that Kobold is installed: Quick Start - 5-minute tutorial Your First Game - Build a complete game Core Documentation - Learn the framework Platform-Specific Notes Windows No special configuration needed. MonoGame uses DirectX or OpenGL backends. macOS MonoGame uses OpenGL. May require allowing the app in Security & Privacy settings. Linux Install MonoGame dependencies: sudo apt-get install mono-complete See Also MonoGame Setup - Detailed MonoGame configuration Quick Start - Get coding in 5 minutes Installation complete? Continue to Quick Start →"
  },
  "Kobold.Documentation/docs/getting-started/quick-start.html": {
    "href": "Kobold.Documentation/docs/getting-started/quick-start.html",
    "title": "Quick Start - 5 Minutes to Your First Game | Kobold Game Framework",
    "summary": "Quick Start - 5 Minutes to Your First Game This guide will get you up and running with Kobold in about 5 minutes. We'll create a simple game with a moving, bouncing sprite. Step 1: Create a New Project (1 minute) # Create a new console application dotnet new console -n MyKoboldGame cd MyKoboldGame # Add required packages (if using NuGet) dotnet add package Kobold.Core dotnet add package Kobold.Monogame dotnet add package MonoGame.Framework.DesktopGL Or if working from the Kobold source repository, add project references instead. Step 2: Create Your Game Class (2 minutes) Replace the contents of Program.cs with: using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using Kobold.Core.Configuration; using Kobold.Monogame; using System.Numerics; using System.Drawing; public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Create a screen bounds entity World.Create( new ScreenBounds { MinX = 0, MaxX = 800, MinY = 0, MaxY = 600 } ); // Create a bouncing ball World.Create( new Transform { Position = new Vector2(400, 300) }, new RectangleRenderer { Size = new Vector2(30, 30), Color = Color.Blue, Layer = 100 }, new Velocity { Value = new Vector2(200, 150) } ); // Add systems var physicsConfig = new PhysicsConfig { EnableGravity = false }; Systems.AddSystem(new PhysicsSystem(physicsConfig), 100, true); Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Bounce), 200, true); Systems.AddRenderSystem(new RenderSystem(Renderer)); } } // Entry point MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My Kobold Game\", BackgroundColor = Color.Black }); Step 3: Run Your Game (30 seconds) dotnet run You should see a window with a blue square bouncing around the screen! What's Happening? Let's break down what this code does: Entities and Components World.Create( new Transform { Position = new Vector2(400, 300) }, new RectangleRenderer { Size = new Vector2(30, 30), Color = Color.Blue }, new Velocity { Value = new Vector2(200, 150) } ); This creates an entity (the blue square) with three components: Transform - Position in the world (center of screen) RectangleRenderer - Visual representation (30x30 blue square) Velocity - Movement direction and speed (200 pixels/sec right, 150 down) Systems Systems.AddSystem(new PhysicsSystem(physicsConfig), 100, true); Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Bounce), 200, true); Systems.AddRenderSystem(new RenderSystem(Renderer)); Systems process entities each frame: PhysicsSystem (order 100) - Moves entities based on their Velocity BoundarySystem (order 200) - Bounces entities off screen edges RenderSystem - Draws entities to the screen The order matters - physics runs first, then boundary checking, then rendering. Next Steps - Add Interactivity Let's make the ball respond to keyboard input. Add this method to your MyGame class: protected override void Update(float deltaTime) { base.Update(deltaTime); // Query for entities with Transform and Velocity var query = World.Query<Transform, Velocity>(); foreach (var entity in query) { ref var velocity = ref entity.Get<Velocity>(); // Arrow keys to control direction if (InputManager.IsKeyDown(KeyCode.Left)) velocity.Value = new Vector2(-200, velocity.Value.Y); if (InputManager.IsKeyDown(KeyCode.Right)) velocity.Value = new Vector2(200, velocity.Value.Y); if (InputManager.IsKeyDown(KeyCode.Up)) velocity.Value = new Vector2(velocity.Value.X, -200); if (InputManager.IsKeyDown(KeyCode.Down)) velocity.Value = new Vector2(velocity.Value.X, 200); } } Now you can control the ball's direction with arrow keys while it bounces! Experiment Further Try these modifications: Change colors: Color = Color.Red // or Green, Yellow, etc. Add more balls: // Create multiple entities in a loop for (int i = 0; i < 10; i++) { World.Create( new Transform { Position = new Vector2(100 + i * 60, 300) }, new RectangleRenderer { Size = new Vector2(20, 20), Color = Color.FromArgb(255, i * 25, 100) }, new Velocity { Value = MathUtils.RandomDirection() * 150 } ); } Add gravity: var physicsConfig = new PhysicsConfig { EnableGravity = true, GlobalGravity = new Vector2(0, 500) // Downward gravity }; Wrap instead of bounce: Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Wrap), 200, true); What You've Learned In just 5 minutes, you've learned: How to create a Kobold project The Entity Component System pattern Creating entities with components Adding and configuring systems The game lifecycle (Initialize, Update, Render) Querying and modifying entities Where to Go Next Your First Game - Build a complete game with more features Core Architecture - Deep dive into ECS concepts Components Reference - All available components Systems Reference - All available systems Code Snippets - Common patterns and recipes Common Issues \"Could not load file or assembly 'MonoGame.Framework'\" Make sure you added the MonoGame.Framework.DesktopGL package Window doesn't appear: Check that you're calling MonoGameHost.Run() at the program entry point Ensure your project type is an executable (not a library) Nothing is rendering: Verify you added RenderSystem to the Systems Check that entities have both Transform and a renderer component (SpriteRenderer, RectangleRenderer, etc.) Having issues? Check the full installation guide or see troubleshooting tips."
  },
  "Kobold.Documentation/docs/getting-started/your-first-game.html": {
    "href": "Kobold.Documentation/docs/getting-started/your-first-game.html",
    "title": "Your First Game - Complete Tutorial | Kobold Game Framework",
    "summary": "Your First Game - Complete Tutorial Build a simple but complete game to learn Kobold fundamentals. We'll create a space shooter with enemies, projectiles, and scoring. What You'll Build Player ship with movement Enemies that spawn periodically Shooting mechanics Collision detection Score tracking Game over screen Prerequisites Kobold installed (Installation Guide) Basic C# knowledge Step 1: Project Setup dotnet new console -n SpaceShooter cd SpaceShooter dotnet add package Kobold.Core dotnet add package Kobold.Monogame dotnet add package MonoGame.Framework.DesktopGL mkdir Content Create simple placeholder graphics in Content/: player.png (32x32 pixel ship) enemy.png (32x32 pixel enemy) bullet.png (8x8 pixel projectile) Step 2: Game Class Create SpaceShooterGame.cs: using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using Kobold.Core.Events; using Kobold.Core.Configuration; using System.Numerics; using System.Drawing; public class SpaceShooterGame : GameEngineBase { private Entity _player; private int _score = 0; private float _enemySpawnTimer = 0; private float _enemySpawnInterval = 2.0f; protected override void Initialize() { base.Initialize(); // Screen bounds World.Create(new ScreenBounds { MinX = 0, MaxX = 800, MinY = 0, MaxY = 600 }); // Load assets var playerTexture = Assets.LoadTexture(\"player.png\"); var enemyTexture = Assets.LoadTexture(\"enemy.png\"); // Create player _player = World.Create( new Transform { Position = new Vector2(400, 500) }, SpriteRenderer.FullTexture(playerTexture), new Velocity(), new PlayerControlled(), BoxCollider.FromRenderSize(32, 32) ); // Add systems var physicsConfig = new PhysicsConfig { EnableGravity = false }; Systems.AddSystem(new PhysicsSystem(physicsConfig), 100, true); var collisionMatrix = CreateCollisionMatrix(); Systems.AddSystem(new CollisionSystem(collisionMatrix), 300, true); Systems.AddSystem(new BoundarySystem(BoundaryBehavior.Clamp), 200, true); Systems.AddRenderSystem(new RenderSystem(Renderer)); // Subscribe to collisions Events.Subscribe<CollisionEvent>(OnCollision); } protected override void Update(float deltaTime) { base.Update(deltaTime); // Player movement HandlePlayerInput(); // Spawn enemies _enemySpawnTimer += deltaTime; if (_enemySpawnTimer >= _enemySpawnInterval) { SpawnEnemy(); _enemySpawnTimer = 0; } } private void HandlePlayerInput() { if (!World.TryGet(_player, out Velocity velocity)) return; var moveSpeed = 300f; var moveX = 0f; if (InputManager.IsKeyDown(KeyCode.A)) moveX = -1; if (InputManager.IsKeyDown(KeyCode.D)) moveX = 1; velocity.Value = new Vector2(moveX * moveSpeed, 0); World.Set(_player, velocity); if (InputManager.IsKeyPressed(KeyCode.Space)) { FireBullet(); } } private void FireBullet() { if (!World.TryGet(_player, out Transform playerTransform)) return; var bulletTexture = Assets.LoadTexture(\"bullet.png\"); World.Create( new Transform { Position = playerTransform.Position }, SpriteRenderer.FullTexture(bulletTexture), new Velocity { Value = new Vector2(0, -500) }, BoxCollider.Square(8), new Lifetime { TimeRemaining = 3f }, new Tags { Values = new[] { \"Bullet\" } } ); } private void SpawnEnemy() { var x = MathUtils.RandomRange(50, 750); var enemyTexture = Assets.LoadTexture(\"enemy.png\"); World.Create( new Transform { Position = new Vector2(x, 50) }, SpriteRenderer.FullTexture(enemyTexture), new Velocity { Value = new Vector2(0, 100) }, BoxCollider.FromRenderSize(32, 32), new Tags { Values = new[] { \"Enemy\" } } ); } private void OnCollision(CollisionEvent collision) { // Bullet hits enemy if (HasTag(collision.EntityA, \"Bullet\") && HasTag(collision.EntityB, \"Enemy\")) { World.Destroy(collision.EntityA); World.Destroy(collision.EntityB); _score += 100; Console.WriteLine($\"Score: {_score}\"); } // Enemy hits player if (HasTag(collision.EntityA, \"Enemy\") && World.Has<PlayerControlled>(collision.EntityB)) { Console.WriteLine(\"Game Over!\"); World.Destroy(collision.EntityA); } } private bool HasTag(Entity entity, string tag) { if (!World.TryGet(entity, out Tags tags)) return false; return tags.Values?.Contains(tag) ?? false; } private CollisionMatrix CreateCollisionMatrix() { var matrix = new CollisionMatrix(); matrix.SetCollision(CollisionLayer.Default, CollisionLayer.Default, true); return matrix; } } Step 3: Entry Point Edit Program.cs: using Kobold.Monogame; using Kobold.Core.Configuration; using System.Drawing; MonoGameHost.Run(new SpaceShooterGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"Space Shooter\", BackgroundColor = Color.Black }); Step 4: Run the Game dotnet run Controls: A/D - Move left/right Space - Shoot What You Learned Game Structure - Extending GameEngineBase Entities & Components - Creating player, enemies, bullets Systems - Physics, Collision, Rendering Input Handling - Keyboard controls Collision Events - Detecting and responding to collisions Spawning - Creating entities during gameplay Timers - Enemy spawn timing Enhancements Try adding: Score display (TextRenderer) Lives system Power-ups Different enemy types Particle effects Sound effects Next Steps Core Architecture - Deep dive into ECS Components - All available components Systems - All available systems Examples - More complex examples Congratulations! You've built your first Kobold game! →"
  },
  "Kobold.Documentation/docs/guides/camera.html": {
    "href": "Kobold.Documentation/docs/guides/camera.html",
    "title": "Camera Systems Guide | Kobold Game Framework",
    "summary": "Camera Systems Guide Camera following, bounds, smooth movement, and viewport management. Basic Camera var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600 } ); Follow Player var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600, FollowTarget = playerEntity, // Entity to follow SmoothSpeed = 5f // Higher = faster following } ); Camera with Bounds var camera = World.Create( new Camera { Position = Vector2.Zero, ViewportWidth = 800, ViewportHeight = 600, FollowTarget = playerEntity, MinBounds = new Vector2(0, 0), MaxBounds = new Vector2(2000, 1500) // Map size } ); Manual Camera Control var query = World.Query<Camera>(); ref var camera = ref query.First().Get<Camera>(); // Move camera camera.Position += new Vector2(10, 0) * deltaTime; // Center on position camera.Position = targetPosition - new Vector2(camera.ViewportWidth / 2, camera.ViewportHeight / 2); Coordinate Conversion // World to screen var screenPos = camera.WorldToScreen(worldPosition); // Screen to world (e.g., for mouse clicks) var worldPos = camera.ScreenToWorld(mousePosition); See Also Camera Component - Full API reference RenderSystem - Camera integration Back: Guides ←"
  },
  "Kobold.Documentation/docs/guides/collision.html": {
    "href": "Kobold.Documentation/docs/guides/collision.html",
    "title": "Collision Handling Guide | Kobold Game Framework",
    "summary": "Collision Handling Guide Set up collision detection, layers, and event handling. Basic Collision Setup // 1. Create collision matrix var matrix = new CollisionMatrix(); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Enemy, true); matrix.SetCollision(CollisionLayer.Projectile, CollisionLayer.Enemy, true); // 2. Add collision system Systems.AddSystem(new CollisionSystem(matrix), 300, true); // 3. Subscribe to collision events Events.Subscribe<CollisionEvent>(OnCollision); // 4. Create entities with colliders World.Create( new Transform(), BoxCollider.Square(32), new Tags { Values = new[] { \"Player\" } } ); Collision Layers public enum CollisionLayer { Default, Player, Enemy, Projectile, Environment, PlayerProjectile, EnemyProjectile, Pickup, Trigger } Collision Matrix Patterns Player vs World var matrix = new CollisionMatrix(); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Environment, true); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Enemy, true); matrix.SetCollision(CollisionLayer.Player, CollisionLayer.Pickup, true); Projectiles // Player projectiles hit enemies matrix.SetCollision(CollisionLayer.PlayerProjectile, CollisionLayer.Enemy, true); // Enemy projectiles hit player matrix.SetCollision(CollisionLayer.EnemyProjectile, CollisionLayer.Player, true); // Projectiles don't hit their own team matrix.SetCollision(CollisionLayer.PlayerProjectile, CollisionLayer.Player, false); matrix.SetCollision(CollisionLayer.EnemyProjectile, CollisionLayer.Enemy, false); Handling Collisions private void OnCollision(CollisionEvent collision) { // Player hit enemy if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Enemy) { Events.Publish(new PlayerHitEvent(collision.EntityA)); } // Projectile hit enemy if (collision.LayerA == CollisionLayer.Projectile && collision.LayerB == CollisionLayer.Enemy) { World.Destroy(collision.EntityA); // Destroy projectile World.Destroy(collision.EntityB); // Destroy enemy } // Player collected pickup if (collision.LayerA == CollisionLayer.Player && collision.LayerB == CollisionLayer.Pickup) { ApplyPickup(collision.EntityA, collision.EntityB); World.Destroy(collision.EntityB); } } See Also CollisionSystem - System API BoxCollider - Collider component Back: Guides ←"
  },
  "Kobold.Documentation/docs/guides/index.html": {
    "href": "Kobold.Documentation/docs/guides/index.html",
    "title": "Practical Guides | Kobold Game Framework",
    "summary": "Practical Guides Step-by-step guides for common game development tasks with Kobold. Available Guides Physics Configuration Configure physics for different game types (platformers, space games, top-down). Collision Handling Set up collision layers, filtering, and event handling. Input Handling Keyboard and mouse input patterns for player controls. Camera Systems Camera following, bounds, smooth movement, and viewport management. Coming Soon Future guides: AI and pathfinding Particle effects UI systems Save/load systems Performance optimization See Also Examples - Code snippets Core Reference - API documentation Choose a guide above to get started! →"
  },
  "Kobold.Documentation/docs/guides/input.html": {
    "href": "Kobold.Documentation/docs/guides/input.html",
    "title": "Input Handling Guide | Kobold Game Framework",
    "summary": "Input Handling Guide Keyboard and mouse input patterns for player controls. Basic Input protected override void Update(float deltaTime) { base.Update(deltaTime); // Key pressed (once per press) if (InputManager.IsKeyPressed(KeyCode.Space)) { FireWeapon(); } // Key held (continuous) if (InputManager.IsKeyDown(KeyCode.W)) { MoveForward(); } } Player Movement Patterns 8-Direction Movement (Top-Down) var players = World.Query<Transform, Velocity, PlayerControlled>(); foreach (var player in players) { ref var velocity = ref player.Get<Velocity>(); var moveDir = Vector2.Zero; if (InputManager.IsKeyDown(KeyCode.W)) moveDir.Y -= 1; if (InputManager.IsKeyDown(KeyCode.S)) moveDir.Y += 1; if (InputManager.IsKeyDown(KeyCode.A)) moveDir.X -= 1; if (InputManager.IsKeyDown(KeyCode.D)) moveDir.X += 1; if (moveDir != Vector2.Zero) { velocity.Value = Vector2.Normalize(moveDir) * 200f; } else { velocity.Value = Vector2.Zero; } } Platformer Controls var moveSpeed = 200f; var jumpForce = -400f; if (InputManager.IsKeyDown(KeyCode.A)) velocity.Value = new Vector2(-moveSpeed, velocity.Value.Y); else if (InputManager.IsKeyDown(KeyCode.D)) velocity.Value = new Vector2(moveSpeed, velocity.Value.Y); else velocity.Value = new Vector2(0, velocity.Value.Y); // Stop horizontal if (InputManager.IsKeyPressed(KeyCode.Space) && isGrounded) { velocity.Value = new Vector2(velocity.Value.X, jumpForce); } Tank Controls (Rotation + Thrust) ref var transform = ref player.Get<Transform>(); ref var velocity = ref player.Get<Velocity>(); var rotSpeed = 3f; var thrustForce = 300f; // Rotate if (InputManager.IsKeyDown(KeyCode.A)) transform.Rotation -= rotSpeed * deltaTime; if (InputManager.IsKeyDown(KeyCode.D)) transform.Rotation += rotSpeed * deltaTime; // Thrust forward if (InputManager.IsKeyDown(KeyCode.W)) { velocity.Value += transform.Forward * thrustForce * deltaTime; } Mouse Input Click to Spawn if (InputManager.IsMouseButtonPressed(MouseButton.Left)) { var mousePos = InputManager.GetMousePosition(); SpawnEntityAt(mousePos); } Aim at Mouse var mousePos = InputManager.GetMousePosition(); var playerPos = transform.Position; var direction = Vector2.Normalize(mousePos - playerPos); transform.Rotation = MathF.Atan2(direction.Y, direction.X); See Also InputManager - API reference Input System - Custom input systems Back: Guides ←"
  },
  "Kobold.Documentation/docs/guides/physics.html": {
    "href": "Kobold.Documentation/docs/guides/physics.html",
    "title": "Physics Configuration Guide | Kobold Game Framework",
    "summary": "Physics Configuration Guide Configure physics simulation for different game types. Physics Profiles Space Game (Asteroids-style) var config = new PhysicsConfig { EnableGravity = false, // No gravity in space EnableDamping = true, GlobalDamping = 0.995f // Minimal friction }; Systems.AddSystem(new PhysicsSystem(config), 100, true); Characteristics: Objects drift continuously Rotation-based thrust Inertia feels realistic Platformer var config = new PhysicsConfig { EnableGravity = true, GlobalGravity = new Vector2(0, 500), // Downward EnableDamping = true, GlobalDamping = 0.98f // Air resistance }; Characteristics: Falling acceleration Jump mechanics Ground friction via damping Top-Down Game (RPG/Twin-stick shooter) var config = new PhysicsConfig { EnableGravity = false, // No vertical gravity EnableDamping = true, GlobalDamping = 0.85f // High friction for responsive controls }; Characteristics: Instant stop when releasing controls No vertical forces Responsive movement Racing Game var config = new PhysicsConfig { EnableGravity = false, EnableDamping = true, GlobalDamping = 0.97f // Moderate deceleration }; // Per-entity max speed ref var velocity = ref entity.Get<Velocity>(); velocity.ClampToMaxSpeed(400f); Per-Entity Physics // Heavy object World.Create( new Transform(), new Velocity(), new Physics { Mass = 10.0f, // Heavier = more gravity effect Restitution = 0.3f, // Low bounce Damping = 0.95f // Overrides global damping } ); // Bouncy ball World.Create( new Transform(), new Velocity(), new Physics { Mass = 1.0f, Restitution = 0.9f, // Very bouncy Damping = 0.99f // Little air resistance } ); See Also PhysicsSystem - System reference Physics Component - Component API Back: Guides ←"
  },
  "Kobold.Documentation/docs/index.html": {
    "href": "Kobold.Documentation/docs/index.html",
    "title": "Home | Kobold Game Framework",
    "summary": "Kobold Kobold is an evolving project meant to make developing 2D games super easy. The goal is to have enough functionality here that any 2D game that fits within a common genre (platformer, roguelike, etc.) can be prototyped within hours, or even faster using AI coding agents.[^1] [^1] At some point, I would like to create some specifications that are meant to be parsed by coding agents for those who are either contributing to or using this project, to ensure high quality and consistent code. This seems like a good time to mention that I am using coding agents to help me build out this repo and review PRs, but I also review changes myself. Furthermore, I believe that all documentation meant to be read by humans should be written by humans. Key Principles Entity-Component-System - The engine is built on this framework using the Arch library. I have written up an explanation of ECS here. Demo-Driven - As I create demos of new types of games, I will add components and systems that seem useful and reusable to the core or extension libraries Extensible - The logic that is common to almost all games will be in Core, while logic specific to certain types of games will be in the Extensions (or other) projects, with clear namespaces so that users can import the pieces that they need. Platform-Agnostic - The Core currently only depends on Arch, and has abstractions for hardware-specific things like input handling and rendering. The Kobold.Monogame project contains Monogame implementations of these abstractions, and all of my demo projects so far use the MonogameHost. If it makes sense, I might see if I can make some of this stuff work with Unity. I may also write my own implementations of the abstractions. We'll see."
  },
  "Kobold.Documentation/docs/monogame/index.html": {
    "href": "Kobold.Documentation/docs/monogame/index.html",
    "title": "Kobold.Monogame - MonoGame Integration | Kobold Game Framework",
    "summary": "Kobold.Monogame - MonoGame Integration Kobold.Monogame provides the MonoGame platform implementation for Kobold.Core's abstractions, enabling rendering, input, and content loading. Overview Kobold.Core defines platform-agnostic interfaces: IRenderer - Drawing graphics IInputManager - Keyboard/mouse input IContentLoader - Loading assets from disk Kobold.Monogame implements these for MonoGame: MonoGameRenderer - Renders using SpriteBatch MonoGameInputManager - Handles MonoGame input MonoGameFileContentLoader - Loads PNG textures directly from files (bypassing Content Pipeline) MonoGameHost - Bootstraps and runs your game MonoGameHost The main class that runs your Kobold game with MonoGame. Usage: MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My Game\" }); What it does: Creates MonoGame Game instance Instantiates platform implementations (Renderer, Input, ContentLoader) Injects them into your GameEngineBase Runs the MonoGame game loop (Update/Render) Platform Implementations MonoGameRenderer Implements IRenderer using MonoGame's SpriteBatch. Features: Sprite rendering with rotation, scale, tint Rectangle, text, triangle, line drawing Pixel-perfect rendering (no sub-pixel coords) Fallback pixel font for text rendering Methods: DrawRectangle(position, size, color) DrawTexture(texture, position, scale) DrawSprite(texture, position, sourceRect, scale, rotation, tint) DrawText(text, position, color, fontSize) DrawTriangle(points, position, rotation, color) DrawLine(start, end, color, thickness) MonoGameInputManager Implements IInputManager using MonoGame's input APIs. Features: Keyboard state tracking (current and previous frames) Mouse position and button states Key press detection (triggered once per press) Methods: IsKeyPressed(KeyCode) - True on first frame of press IsKeyDown(KeyCode) - True while held IsKeyUp(KeyCode) - True while not pressed GetMousePosition() - Mouse coordinates IsMouseButtonPressed(MouseButton) - Mouse click detection MonoGameFileContentLoader Implements IContentLoader for loading PNG textures directly from the file system at runtime. Features: Loads raw PNG files from disk (bypasses MonoGame Content Pipeline) Uses Texture2D.FromStream for runtime loading Supports relative and absolute paths Auto-adds .png extension if missing Configurable content root directory Usage: var loader = new MonoGameFileContentLoader(graphicsDevice, \"Content\"); var texture = loader.LoadTexture(\"player.png\"); // Loads from Content/player.png Note: This implementation does NOT use the MonoGame Content Pipeline (XNB files). For a pipeline-based loader, use MonoGamePipelineContentLoader (not yet implemented). MonoGameTexture Wraps MonoGame's Texture2D to implement ITexture. Properties: Width - Texture width in pixels Height - Texture height in pixels Quick Start 1. Create Game Class using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using Kobold.Monogame; public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Create entities var texture = Assets.LoadTexture(\"player.png\"); World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FullTexture(texture) ); // Add systems Systems.AddRenderSystem(new RenderSystem(Renderer)); } } 2. Run with MonoGameHost // Program.cs MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My Kobold Game\" }); 3. Add Content Files Place your PNG files in the Content/ directory at your project root. Dependencies Kobold.Monogame requires: Kobold.Core - Core framework MonoGame.Framework.DesktopGL - MonoGame (cross-platform) .NET 8.0 - Runtime Platform Support MonoGame supports: Windows (DesktopGL) macOS (DesktopGL) Linux (DesktopGL) Kobold can potentially support other MonoGame backends with custom implementations. See Also Setup Guide - Detailed MonoGame project setup Core Framework - Platform-agnostic abstractions Next: Setup Guide for detailed project configuration →"
  },
  "Kobold.Documentation/docs/monogame/setup.html": {
    "href": "Kobold.Documentation/docs/monogame/setup.html",
    "title": "MonoGame Project Setup | Kobold Game Framework",
    "summary": "MonoGame Project Setup This guide walks through setting up a Kobold game project with MonoGame. Prerequisites .NET 8 SDK - Download here IDE - Visual Studio, VS Code, or JetBrains Rider Project Setup Option 1: Using NuGet Packages (Recommended for Distribution) # Create new console application dotnet new console -n MyKoboldGame cd MyKoboldGame # Add Kobold packages dotnet add package Kobold.Core dotnet add package Kobold.Monogame dotnet add package MonoGame.Framework.DesktopGL # Optional packages dotnet add package Kobold.Extensions # Tilemaps dotnet add package Kobold.Procedural # Procedural generation Option 2: Using Source (Recommended for Development) Clone the Kobold repository and reference projects directly: <!-- MyKoboldGame.csproj --> <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> </PropertyGroup> <ItemGroup> <ProjectReference Include=\"..\\Kobold\\Kobold\\Kobold.csproj\" /> <ProjectReference Include=\"..\\Kobold\\Kobold.Monogame\\Kobold.Monogame.csproj\" /> </ItemGroup> </Project> Project Structure MyKoboldGame/ ├── Program.cs ├── MyGame.cs ├── Content/ │ ├── player.png │ ├── enemy.png │ └── background.png └── MyKoboldGame.csproj Content Files MonoGame projects need a Content/ directory for assets. Create Content Directory mkdir Content Add Content Files Place PNG files in Content/: Content/player.png Content/enemy.png Content/background.png Configure Content Copying Update your .csproj to copy content files to output: <ItemGroup> <Content Include=\"Content\\**\\*\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </Content> </ItemGroup> Code Setup Program.cs using Kobold.Monogame; using Kobold.Core.Configuration; using System.Drawing; MonoGameHost.Run(new MyGame(), new GameConfig { WindowWidth = 800, WindowHeight = 600, WindowTitle = \"My Kobold Game\", BackgroundColor = Color.Black }); MyGame.cs using Kobold.Core; using Kobold.Core.Components; using Kobold.Core.Systems; using System.Numerics; public class MyGame : GameEngineBase { protected override void Initialize() { base.Initialize(); // Load assets var playerTexture = Assets.LoadTexture(\"player.png\"); // Create entities World.Create( new Transform { Position = new Vector2(400, 300) }, SpriteRenderer.FullTexture(playerTexture) ); // Add systems Systems.AddRenderSystem(new RenderSystem(Renderer)); } } Running Your Game dotnet run You should see a window with your sprite! Troubleshooting \"Could not load file or assembly 'MonoGame.Framework'\" Ensure MonoGame.Framework.DesktopGL is installed Check target framework is .NET 8.0 \"Texture not found\" Verify PNG files are in Content/ directory Check .csproj has Content copying configured Ensure file names match (case-sensitive on Linux/macOS) Window doesn't appear Verify MonoGameHost.Run() is called in Program.cs Check OutputType is Exe in .csproj See Also Quick Start - 5-minute tutorial MonoGame Documentation - Official MonoGame docs Ready to build? Check out the Getting Started tutorials!"
  },
  "Kobold.Documentation/docs/procedural/cave-generation.html": {
    "href": "Kobold.Documentation/docs/procedural/cave-generation.html",
    "title": "Cave Generation - Cellular Automata | Kobold Game Framework",
    "summary": "Cave Generation - Cellular Automata Generate organic cave-like structures using cellular automata algorithms. How It Works Initialize: Randomly place walls based on density Smooth: Apply cellular automata rules (like Conway's Game of Life) for N iterations Connect: Optionally connect separate cave regions with corridors Clean: Remove small isolated regions Quick Start using Kobold.Procedural; using Kobold.Extensions.Tilemaps; // Create configuration var config = CellularAutomataConfig.Cave(); config.Width = 64; config.Height = 48; config.Seed = 12345; // For reproducible results // Generate cave var generator = new CellularAutomataGenerator(config); var (tileMap, tileSet) = generator.GenerateWithTileSet(wallIsSolid: true); // Use in game var texture = Assets.LoadTexture(\"tiles.png\"); World.Create(new TilemapComponent(tileMap, tileSet, texture)); Configuration CellularAutomataConfig public class CellularAutomataConfig { public int Width, Height; // Map size in tiles public int Iterations; // Smoothing passes (4-6 recommended) public float InitialWallProbability; // Starting density (0.4-0.5 for caves) public int BirthThreshold; // Neighbors to become wall (4) public int DeathThreshold; // Neighbors to stay wall (3) public int Seed; // Random seed (0 = random) public int WallTileId, FloorTileId; // Tile IDs public int TileWidth, TileHeight; // Pixel dimensions public bool EdgeIsWall; // Treat boundaries as walls public bool ConnectCaves; // Connect separate regions public int MinCaveSize; // Minimum tiles to keep region } Presets // Organic caves (recommended) var config = CellularAutomataConfig.Cave(); // Open areas with sparse obstacles var config = CellularAutomataConfig.OpenArea(); // Dense maze-like patterns var config = CellularAutomataConfig.Maze(); Examples Basic Cave var config = new CellularAutomataConfig { Width = 48, Height = 32, TileWidth = 32, TileHeight = 32, Iterations = 5, InitialWallProbability = 0.45f, BirthThreshold = 4, DeathThreshold = 3, ConnectCaves = true, MinCaveSize = 50 }; var generator = new CellularAutomataGenerator(config); var (tileMap, tileSet) = generator.GenerateWithTileSet(); Reproducible Generation var config = CellularAutomataConfig.Cave(); config.Seed = 42; // Same seed = same cave var gen1 = new CellularAutomataGenerator(config); var gen2 = new CellularAutomataGenerator(config); // Both generate identical caves Large Open Cave var config = new CellularAutomataConfig { Width = 80, Height = 60, Iterations = 6, InitialWallProbability = 0.35f, // Less dense ConnectCaves = true }; Complete Example See CaveExplorer game for a complete implementation with player movement, tilemap collision, and camera following. Tips More iterations = smoother, rounder caves Higher density (0.5+) = smaller caves, more walls Lower density (0.3-0.4) = larger open caves ConnectCaves = true ensures all areas reachable MinCaveSize removes tiny disconnected rooms See Also Tilemaps - Using generated tilemaps CaveExplorer Example - Complete game Back: Procedural Overview ←"
  },
  "Kobold.Documentation/docs/procedural/index.html": {
    "href": "Kobold.Documentation/docs/procedural/index.html",
    "title": "Kobold.Procedural - Procedural Generation | Kobold Game Framework",
    "summary": "Kobold.Procedural - Procedural Generation Kobold.Procedural provides algorithms for generating procedural game content. Overview Procedural generation creates unique, dynamic content algorithmically rather than hand-crafting every level. Kobold.Procedural currently provides cellular automata-based cave generation. Current Generators Cellular Automata Cave Generator Generates organic cave-like structures using cellular automata algorithms. Features: Configurable parameters (density, smoothing, size) Cave connection (ensures all areas reachable) Small region removal Preset configurations (Cave, OpenArea, Maze) Outputs TileMap compatible with Kobold.Extensions Quick Example: var config = CellularAutomataConfig.Cave(); config.Width = 64; config.Height = 48; config.ConnectCaves = true; var generator = new CellularAutomataGenerator(config); var (tileMap, tileSet) = generator.GenerateWithTileSet(wallIsSolid: true); // Use the generated tilemap var texture = Assets.LoadTexture(\"tiles.png\"); World.Create(new TilemapComponent(tileMap, tileSet, texture)); Installation dotnet add package Kobold.Procedural Or reference the project: <ProjectReference Include=\"..\\Kobold.Procedural\\Kobold.Procedural.csproj\" /> Dependencies Kobold.Extensions - Outputs TileMap/TileSet Future Generators Potential future additions: Dungeon generation (rooms + corridors) Noise-based terrain Wave Function Collapse L-systems for organic structures See Also Cave Generation Guide - Detailed cellular automata tutorial Tilemaps - Using generated tilemaps CaveExplorer Example - Complete example game Next: Cave Generation - Learn the algorithm →"
  },
  "Kobold.Documentation/docs/tools/experiments.html": {
    "href": "Kobold.Documentation/docs/tools/experiments.html",
    "title": "Experiments Sandbox | Kobold Game Framework",
    "summary": "Experiments Sandbox Interactive testing environment for Kobold features using Rapid.NET. Overview Kobold.Experiments provides a sandbox for testing features with real-time parameter tweaking via an automatically generated UI. Features Rapid.NET Integration - Automatic UI from code attributes Real-time Updates - Change parameters without recompiling Visual Output - See results immediately Current Experiments: Cellular Automata Cave Generation Usage Run Experiments cd Kobold.Experiments dotnet run A WPF window appears with: Left Panel: Parameter controls Right Panel: Visual output Current: Cellular Automata Test cave generation with configurable parameters: Map dimensions (width, height) Smoothing iterations Wall probability Birth/death thresholds Random seed Cave connection settings Adjust parameters and click \"Run\" to see updated results instantly. Creating New Experiments Add a new script class: [Script(\"My Experiment\", \"Description\")] public class MyExperimentScript { [IntSlider(1, 100, \"Width\", \"Map width\")] public int Width { get; set; } = 50; [FloatSlider(0, 1, \"Density\", \"Initial density\")] public float Density { get; set; } = 0.5f; [Button(\"Generate\", \"Run generation\")] public void Generate() { // Your experiment code } } Rapid.NET automatically generates UI from attributes. See Also Procedural Generation - Algorithms being tested Rapid.NET Documentation - UI framework Back: Tools Overview ←"
  },
  "Kobold.Documentation/docs/tools/index.html": {
    "href": "Kobold.Documentation/docs/tools/index.html",
    "title": "Development Tools | Kobold Game Framework",
    "summary": "Development Tools Kobold provides several tools to streamline game development workflows. Sprite Sheet Editor Visual tool for creating sprite sheet configuration files. Features: Load sprite sheet images Define grid parameters (tile size, spacing, margin) Visual grid overlay Interactive sprite selection Export JSON configurations Camera controls (pan, zoom) Use for: Creating sprite sheet configs for animations Defining named regions Testing sprite layouts Quick Start: cd Kobold.SpriteSheetEditor dotnet run Experiments Sandbox Interactive testing environment for Kobold features. Features: Rapid.NET UI for parameter tweaking Test procedural generation algorithms Visualize results in real-time No recompilation needed for parameter changes Use for: Testing cellular automata configurations Experimenting with new features Prototyping game mechanics Quick Start: cd Kobold.Experiments dotnet run See Also Sprite Sheet Editor Guide - Detailed usage Experiments Guide - Interactive testing Next: Sprite Sheet Editor →"
  },
  "Kobold.Documentation/docs/tools/sprite-sheet-editor.html": {
    "href": "Kobold.Documentation/docs/tools/sprite-sheet-editor.html",
    "title": "Sprite Sheet Editor | Kobold Game Framework",
    "summary": "Sprite Sheet Editor Visual tool for creating sprite sheet configuration JSON files used by Kobold's asset system. Overview The Sprite Sheet Editor helps you: Load a sprite sheet image (PNG) Define the grid layout (width, height, spacing, margin) Visually verify the grid aligns with your sprites Export a JSON configuration file Usage 1. Run the Editor cd Kobold.SpriteSheetEditor dotnet run 2. Load Image Place your sprite sheet PNG in the project directory or provide the full path. Edit SpriteSheetEditorGame.cs to change the default image: var texturePath = \"your_spritesheet.png\"; 3. Adjust Grid Keyboard Controls: Arrow Keys - Adjust grid cell size G - Toggle grid visibility W/A/S/D - Pan camera Q/E - Zoom out/in 0 - Reset zoom Ctrl+S - Save configuration (future feature) 4. Configure Parameters Edit the code to set: spriteWidth, spriteHeight - Size of each sprite in pixels columns, rows - Grid dimensions spacing - Gap between sprites margin - Border around the sprite sheet 5. Export Configuration The editor displays the configuration in the window title. Create a JSON file manually: { \"texture\": \"player.png\", \"spriteWidth\": 32, \"spriteHeight\": 32, \"columns\": 8, \"rows\": 4, \"spacing\": 0, \"margin\": 0 } Save as player.json in your Content directory. Tips Use a checkerboard background to verify transparency Zoom in to verify pixel-perfect alignment Common sprite sizes: 16x16, 32x32, 64x64 See Also Asset Manager - Using sprite sheet configs Animation - Sprite animation Back: Tools Overview ←"
  },
  "api/Experiments.CellularAutomataDisplay.html": {
    "href": "api/Experiments.CellularAutomataDisplay.html",
    "title": "Class CellularAutomataDisplay | Kobold Game Framework",
    "summary": "Class CellularAutomataDisplay Namespace Experiments Assembly Experiments.dll Game that displays a cellular automata generated tilemap. public class CellularAutomataDisplay : GameEngineBase, IGameEngine Inheritance object GameEngineBase CellularAutomataDisplay Implements IGameEngine Inherited Members GameEngineBase.World GameEngineBase.Renderer GameEngineBase.InputManager GameEngineBase.ContentLoader GameEngineBase.Assets GameEngineBase.EventBus GameEngineBase.SystemManager GameEngineBase.SetRenderer(IRenderer) GameEngineBase.SetInputManager(IInputManager) GameEngineBase.SetContentLoader(IContentLoader) GameEngineBase.Shutdown() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CellularAutomataDisplay(CellularAutomataConfig) public CellularAutomataDisplay(CellularAutomataConfig config) Parameters config CellularAutomataConfig CellularAutomataDisplay(CellularAutomataConfig, IRenderer, IInputManager) public CellularAutomataDisplay(CellularAutomataConfig config, IRenderer renderer, IInputManager inputManager) Parameters config CellularAutomataConfig renderer IRenderer inputManager IInputManager Methods CreateConfig(int, int) public static GameConfig CreateConfig(int width, int height) Parameters width int height int Returns GameConfig Initialize() public override void Initialize() Render() public override void Render() Update(float) public override void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Experiments.CellularAutomataScript.Config.html": {
    "href": "api/Experiments.CellularAutomataScript.Config.html",
    "title": "Class CellularAutomataScript.Config | Kobold Game Framework",
    "summary": "Class CellularAutomataScript.Config Namespace Experiments Assembly Experiments.dll [Documentation(\"Configuration parameters for cellular automata generation\")] public class CellularAutomataScript.Config Inheritance object CellularAutomataScript.Config Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BirthThreshold [Documentation(\"Neighbors needed for a cell to become a wall (0-8)\")] public int BirthThreshold Field Value int ConnectCaves [Documentation(\"Connect all caves with corridors for full reachability\")] public bool ConnectCaves Field Value bool DeathThreshold [Documentation(\"Max neighbors for a wall to stay alive (0-8)\")] public int DeathThreshold Field Value int EdgeIsWall [Documentation(\"Whether map edges count as walls\")] public bool EdgeIsWall Field Value bool FloorTileId [Documentation(\"Tile ID to use for floor\")] public int FloorTileId Field Value int Height [Documentation(\"Height of the map in tiles (1-200)\")] public int Height Field Value int InitialWallProbability [Documentation(\"Initial chance that a cell is a wall (0.0-1.0)\")] public float InitialWallProbability Field Value float Iterations [Documentation(\"Number of smoothing iterations (0-20)\")] public int Iterations Field Value int MinCaveSize [Documentation(\"Minimum size for a cave region (smaller ones are removed)\")] public int MinCaveSize Field Value int Seed [Documentation(\"Random seed (0 for random)\")] public int Seed Field Value int TileHeight [Documentation(\"Tile height in pixels (for rendering)\")] public int TileHeight Field Value int TileWidth [Documentation(\"Tile width in pixels (for rendering)\")] public int TileWidth Field Value int WallTileId [Documentation(\"Tile ID to use for walls\")] public int WallTileId Field Value int Width [Documentation(\"Width of the map in tiles (1-200)\")] public int Width Field Value int"
  },
  "api/Experiments.CellularAutomataScript.html": {
    "href": "api/Experiments.CellularAutomataScript.html",
    "title": "Class CellularAutomataScript | Kobold Game Framework",
    "summary": "Class CellularAutomataScript Namespace Experiments Assembly Experiments.dll [Script] [Documentation(\"Generate and visualize cellular automata with configurable parameters\")] public class CellularAutomataScript Inheritance object CellularAutomataScript Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Run(Config) public static void Run(CellularAutomataScript.Config cfg) Parameters cfg CellularAutomataScript.Config"
  },
  "api/Experiments.Program.html": {
    "href": "api/Experiments.Program.html",
    "title": "Class Program | Kobold Game Framework",
    "summary": "Class Program Namespace Experiments Assembly Experiments.dll public class Program Inheritance object Program Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Main(string[]) [STAThread] public static void Main(string[] args) Parameters args string[]"
  },
  "api/Experiments.html": {
    "href": "api/Experiments.html",
    "title": "Namespace Experiments | Kobold Game Framework",
    "summary": "Namespace Experiments Classes CellularAutomataDisplay Game that displays a cellular automata generated tilemap. CellularAutomataScript CellularAutomataScript.Config Program"
  },
  "api/Kobold.Core.Abstractions.Core.IContentLoader.html": {
    "href": "api/Kobold.Core.Abstractions.Core.IContentLoader.html",
    "title": "Interface IContentLoader | Kobold Game Framework",
    "summary": "Interface IContentLoader Namespace Kobold.Core.Abstractions.Core Assembly Kobold.Core.dll Interface for loading game content (textures, sounds, etc.) public interface IContentLoader Properties ContentRoot Root directory for content files string ContentRoot { get; } Property Value string Methods LoadTexture(string) Load a texture from a file path ITexture LoadTexture(string path) Parameters path string Path to the texture file (relative to content directory) Returns ITexture The loaded texture TextureExists(string) Check if a texture file exists bool TextureExists(string path) Parameters path string Path to check Returns bool True if the file exists"
  },
  "api/Kobold.Core.Abstractions.Core.IGameEngine.html": {
    "href": "api/Kobold.Core.Abstractions.Core.IGameEngine.html",
    "title": "Interface IGameEngine | Kobold Game Framework",
    "summary": "Interface IGameEngine Namespace Kobold.Core.Abstractions.Core Assembly Kobold.Core.dll The basic definition of what makes a game. A game is initialized once at the beginning and shut down once at the end, and in between, the game runs. While it runs, there is a loop. In every iteration of the loop, the state of everything that exists in the game (the \"entities\") is updated and then the current state of the game is rendered. The update loop requires knowledge of how much time has passed since the last update was called (the \"delta time\") since update loops may run at different rates on different hardware. public interface IGameEngine Methods Initialize() void Initialize() Render() void Render() Shutdown() void Shutdown() Update(float) void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Abstractions.Core.html": {
    "href": "api/Kobold.Core.Abstractions.Core.html",
    "title": "Namespace Kobold.Core.Abstractions.Core | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Abstractions.Core Interfaces IContentLoader Interface for loading game content (textures, sounds, etc.) IGameEngine The basic definition of what makes a game. A game is initialized once at the beginning and shut down once at the end, and in between, the game runs. While it runs, there is a loop. In every iteration of the loop, the state of everything that exists in the game (the \"entities\") is updated and then the current state of the game is rendered. The update loop requires knowledge of how much time has passed since the last update was called (the \"delta time\") since update loops may run at different rates on different hardware."
  },
  "api/Kobold.Core.Abstractions.IRenderSystem.html": {
    "href": "api/Kobold.Core.Abstractions.IRenderSystem.html",
    "title": "Interface IRenderSystem | Kobold Game Framework",
    "summary": "Interface IRenderSystem Namespace Kobold.Core.Abstractions Assembly Kobold.Core.dll Interface for systems that only need to render. public interface IRenderSystem Methods Render() void Render()"
  },
  "api/Kobold.Core.Abstractions.ISystem.html": {
    "href": "api/Kobold.Core.Abstractions.ISystem.html",
    "title": "Interface ISystem | Kobold Game Framework",
    "summary": "Interface ISystem Namespace Kobold.Core.Abstractions Assembly Kobold.Core.dll At its core, a system is just a thing that is reponsible for applying updates to entities. public interface ISystem Methods Update(float) void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Abstractions.Input.IInputManager.html": {
    "href": "api/Kobold.Core.Abstractions.Input.IInputManager.html",
    "title": "Interface IInputManager | Kobold Game Framework",
    "summary": "Interface IInputManager Namespace Kobold.Core.Abstractions.Input Assembly Kobold.Core.dll The input manager is responsible for getting input from the hardware public interface IInputManager Methods GetMousePosition() Vector2 GetMousePosition() Returns Vector2 IsKeyDown(KeyCode) bool IsKeyDown(KeyCode key) Parameters key KeyCode Returns bool IsKeyPressed(KeyCode) bool IsKeyPressed(KeyCode key) Parameters key KeyCode Returns bool IsKeyUp(KeyCode) bool IsKeyUp(KeyCode key) Parameters key KeyCode Returns bool IsMouseButtonPressed(MouseButton) bool IsMouseButtonPressed(MouseButton button) Parameters button MouseButton Returns bool"
  },
  "api/Kobold.Core.Abstractions.Input.KeyCode.html": {
    "href": "api/Kobold.Core.Abstractions.Input.KeyCode.html",
    "title": "Enum KeyCode | Kobold Game Framework",
    "summary": "Enum KeyCode Namespace Kobold.Core.Abstractions.Input Assembly Kobold.Core.dll public enum KeyCode Fields A = 1 D = 3 Down = 8 Enter = 5 Escape = 6 Left = 9 P = 11 Right = 10 S = 2 Space = 4 Up = 7 W = 0"
  },
  "api/Kobold.Core.Abstractions.Input.MouseButton.html": {
    "href": "api/Kobold.Core.Abstractions.Input.MouseButton.html",
    "title": "Enum MouseButton | Kobold Game Framework",
    "summary": "Enum MouseButton Namespace Kobold.Core.Abstractions.Input Assembly Kobold.Core.dll public enum MouseButton Fields Left = 0 Middle = 2 Right = 1"
  },
  "api/Kobold.Core.Abstractions.Input.html": {
    "href": "api/Kobold.Core.Abstractions.Input.html",
    "title": "Namespace Kobold.Core.Abstractions.Input | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Abstractions.Input Interfaces IInputManager The input manager is responsible for getting input from the hardware Enums KeyCode MouseButton"
  },
  "api/Kobold.Core.Abstractions.Rendering.IRenderer.html": {
    "href": "api/Kobold.Core.Abstractions.Rendering.IRenderer.html",
    "title": "Interface IRenderer | Kobold Game Framework",
    "summary": "Interface IRenderer Namespace Kobold.Core.Abstractions.Rendering Assembly Kobold.Core.dll The renderer defines how stuff actually gets drawn to the screen public interface IRenderer Methods Begin() void Begin() DrawLine(Vector2, Vector2, Color, float) void DrawLine(Vector2 start, Vector2 end, Color color, float thickness = 1) Parameters start Vector2 end Vector2 color Color thickness float DrawRectangle(Vector2, Vector2, Color) void DrawRectangle(Vector2 position, Vector2 size, Color color) Parameters position Vector2 size Vector2 color Color DrawSprite(ITexture, Vector2, Rectangle, Vector2, float, Color) void DrawSprite(ITexture texture, Vector2 position, Rectangle sourceRect, Vector2 scale, float rotation, Color tint) Parameters texture ITexture position Vector2 sourceRect Rectangle scale Vector2 rotation float tint Color DrawText(string, Vector2, Color, float) void DrawText(string text, Vector2 position, Color color, float fontSize = 16) Parameters text string position Vector2 color Color fontSize float DrawTexture(ITexture, Vector2, Vector2) void DrawTexture(ITexture texture, Vector2 position, Vector2 scale = default) Parameters texture ITexture position Vector2 scale Vector2 DrawTriangle(Vector2[], Vector2, float, Color) void DrawTriangle(Vector2[] points, Vector2 position, float rotation, Color color) Parameters points Vector2[] position Vector2 rotation float color Color DrawTriangleFilled(Vector2[], Vector2, float, Color) void DrawTriangleFilled(Vector2[] points, Vector2 position, float rotation, Color color) Parameters points Vector2[] position Vector2 rotation float color Color End() void End()"
  },
  "api/Kobold.Core.Abstractions.Rendering.ITexture.html": {
    "href": "api/Kobold.Core.Abstractions.Rendering.ITexture.html",
    "title": "Interface ITexture | Kobold Game Framework",
    "summary": "Interface ITexture Namespace Kobold.Core.Abstractions.Rendering Assembly Kobold.Core.dll An abstraction for an image that can be rendered by the graphics backend public interface ITexture Properties Height int Height { get; } Property Value int Width int Width { get; } Property Value int"
  },
  "api/Kobold.Core.Abstractions.Rendering.html": {
    "href": "api/Kobold.Core.Abstractions.Rendering.html",
    "title": "Namespace Kobold.Core.Abstractions.Rendering | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Abstractions.Rendering Interfaces IRenderer The renderer defines how stuff actually gets drawn to the screen ITexture An abstraction for an image that can be rendered by the graphics backend"
  },
  "api/Kobold.Core.Abstractions.html": {
    "href": "api/Kobold.Core.Abstractions.html",
    "title": "Namespace Kobold.Core.Abstractions | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Abstractions Interfaces IRenderSystem Interface for systems that only need to render. ISystem At its core, a system is just a thing that is reponsible for applying updates to entities."
  },
  "api/Kobold.Core.AssetManager.html": {
    "href": "api/Kobold.Core.AssetManager.html",
    "title": "Class AssetManager | Kobold Game Framework",
    "summary": "Class AssetManager Namespace Kobold.Core Assembly Kobold.Core.dll Manages loading and caching of game assets (textures, sprite sheets, etc.) public class AssetManager Inheritance object AssetManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AssetManager(IContentLoader, string) public AssetManager(IContentLoader contentLoader, string contentRoot = \"Content\") Parameters contentLoader IContentLoader contentRoot string Properties CachedSpriteSheetCount Get count of currently cached sprite sheets public int CachedSpriteSheetCount { get; } Property Value int CachedTextureCount Get count of currently cached textures public int CachedTextureCount { get; } Property Value int Methods GetCachedSpriteSheetPaths() Get all currently cached sprite sheet paths public IEnumerable<string> GetCachedSpriteSheetPaths() Returns IEnumerable<string> GetCachedTexturePaths() Get all currently cached texture paths public IEnumerable<string> GetCachedTexturePaths() Returns IEnumerable<string> GetSpriteSheet(string) Get a previously loaded sprite sheet from cache public SpriteSheet? GetSpriteSheet(string path) Parameters path string Path to the sprite sheet Returns SpriteSheet The cached sprite sheet, or null if not loaded GetTexture(string) Get a previously loaded texture from cache public ITexture? GetTexture(string path) Parameters path string Path to the texture Returns ITexture The cached texture, or null if not loaded IsSpriteSheetLoaded(string) Check if a sprite sheet is already loaded in cache public bool IsSpriteSheetLoaded(string path) Parameters path string Path to check Returns bool True if the sprite sheet is cached IsTextureLoaded(string) Check if a texture is already loaded in cache public bool IsTextureLoaded(string path) Parameters path string Path to check Returns bool True if the texture is cached LoadSpriteSheet(string) Load a sprite sheet with its configuration (expects .png and .json files) public SpriteSheet LoadSpriteSheet(string path) Parameters path string Path to the sprite sheet (without extension) Returns SpriteSheet The loaded sprite sheet LoadSpriteSheetConfig(string) Load a sprite sheet configuration from a JSON file public SpriteSheetConfig LoadSpriteSheetConfig(string configPath) Parameters configPath string Path to the JSON config file Returns SpriteSheetConfig The loaded configuration LoadTexture(string) Load a texture, or return cached version if already loaded public ITexture LoadTexture(string path) Parameters path string Path to the texture file Returns ITexture The loaded texture PreloadTextures(params string[]) Preload multiple textures at once (useful for loading screens) public void PreloadTextures(params string[] paths) Parameters paths string[] Array of texture paths to preload SaveSpriteSheetConfig(SpriteSheetConfig, string) Save a sprite sheet configuration to a JSON file public void SaveSpriteSheetConfig(SpriteSheetConfig config, string configPath) Parameters config SpriteSheetConfig The configuration to save configPath string Path where to save the config UnloadAll() Unload all assets (textures and sprite sheets) public void UnloadAll() UnloadAllSpriteSheets() Unload all cached sprite sheets public void UnloadAllSpriteSheets() UnloadAllTextures() Unload all cached textures public void UnloadAllTextures() UnloadSpriteSheet(string) Unload a specific sprite sheet from cache public bool UnloadSpriteSheet(string path) Parameters path string Path to the sprite sheet to unload Returns bool True if the sprite sheet was unloaded, false if it wasn't cached UnloadTexture(string) Unload a specific texture from cache public bool UnloadTexture(string path) Parameters path string Path to the texture to unload Returns bool True if the texture was unloaded, false if it wasn't cached"
  },
  "api/Kobold.Core.Assets.AnimationData.html": {
    "href": "api/Kobold.Core.Assets.AnimationData.html",
    "title": "Class AnimationData | Kobold Game Framework",
    "summary": "Class AnimationData Namespace Kobold.Core.Assets Assembly Kobold.Core.dll Animation configuration data public class AnimationData Inheritance object AnimationData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Fps Frames per second public float Fps { get; set; } Property Value float FrameCount Number of frames in the animation public int FrameCount { get; set; } Property Value int FrameIndices Custom frame indices (overrides StartFrame/FrameCount) public int[]? FrameIndices { get; set; } Property Value int[] Loop Whether the animation should loop public bool Loop { get; set; } Property Value bool Row Row number (alternative to StartFrame for grid-based) public int? Row { get; set; } Property Value int? StartColumn Starting column (used with Row) public int? StartColumn { get; set; } Property Value int? StartFrame Starting frame index (in grid order: left-to-right, top-to-bottom) public int StartFrame { get; set; } Property Value int"
  },
  "api/Kobold.Core.Assets.RectangleData.html": {
    "href": "api/Kobold.Core.Assets.RectangleData.html",
    "title": "Class RectangleData | Kobold Game Framework",
    "summary": "Class RectangleData Namespace Kobold.Core.Assets Assembly Kobold.Core.dll Rectangle data for JSON serialization public class RectangleData Inheritance object RectangleData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Height public int Height { get; set; } Property Value int Width public int Width { get; set; } Property Value int X public int X { get; set; } Property Value int Y public int Y { get; set; } Property Value int Methods FromRectangle(Rectangle) public static RectangleData FromRectangle(Rectangle r) Parameters r Rectangle Returns RectangleData ToRectangle() public Rectangle ToRectangle() Returns Rectangle"
  },
  "api/Kobold.Core.Assets.SpriteSheet.html": {
    "href": "api/Kobold.Core.Assets.SpriteSheet.html",
    "title": "Class SpriteSheet | Kobold Game Framework",
    "summary": "Class SpriteSheet Namespace Kobold.Core.Assets Assembly Kobold.Core.dll Represents a sprite sheet with its texture and configuration public class SpriteSheet Inheritance object SpriteSheet Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SpriteSheet(ITexture, SpriteSheetConfig) public SpriteSheet(ITexture texture, SpriteSheetConfig config) Parameters texture ITexture config SpriteSheetConfig Properties Config public SpriteSheetConfig Config { get; } Property Value SpriteSheetConfig Texture public ITexture Texture { get; } Property Value ITexture TotalFrames Get total number of frames in the sprite sheet public int TotalFrames { get; } Property Value int Methods CreateAllAnimations() Create all configured animations as AnimationClips public Dictionary<string, AnimationClip> CreateAllAnimations() Returns Dictionary<string, AnimationClip> CreateAnimationClip(string) Create an AnimationClip from a configured animation public AnimationClip CreateAnimationClip(string animationName) Parameters animationName string Returns AnimationClip GetAnimationFrames(AnimationData) Get all frames for an animation from AnimationData public Rectangle[] GetAnimationFrames(AnimationData animData) Parameters animData AnimationData Returns Rectangle[] GetAnimationFrames(string) Get all frames for an animation as rectangles public Rectangle[] GetAnimationFrames(string animationName) Parameters animationName string Returns Rectangle[] GetFrame(int) Get a sprite frame by grid index (0-based, left-to-right, top-to-bottom) public Rectangle GetFrame(int index) Parameters index int Returns Rectangle GetFrameByRowCol(int, int) Get a sprite frame by row and column public Rectangle GetFrameByRowCol(int row, int col) Parameters row int col int Returns Rectangle GetNamedRegion(string) Get a named region from the sprite sheet public Rectangle GetNamedRegion(string name) Parameters name string Returns Rectangle HasNamedRegion(string) Check if a named region exists public bool HasNamedRegion(string name) Parameters name string Returns bool"
  },
  "api/Kobold.Core.Assets.SpriteSheetConfig.html": {
    "href": "api/Kobold.Core.Assets.SpriteSheetConfig.html",
    "title": "Class SpriteSheetConfig | Kobold Game Framework",
    "summary": "Class SpriteSheetConfig Namespace Kobold.Core.Assets Assembly Kobold.Core.dll Configuration for how a sprite sheet should be divided public class SpriteSheetConfig Inheritance object SpriteSheetConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Animations Animation definitions public Dictionary<string, AnimationData> Animations { get; set; } Property Value Dictionary<string, AnimationData> Columns Number of columns in the sprite sheet public int Columns { get; set; } Property Value int Margin Margin around the sprite sheet in pixels (default 0) public int Margin { get; set; } Property Value int Metadata Metadata (optional user data) public Dictionary<string, string> Metadata { get; set; } Property Value Dictionary<string, string> NamedRegions Named regions for specific sprites or groups public Dictionary<string, RectangleData> NamedRegions { get; set; } Property Value Dictionary<string, RectangleData> Pivot Default pivot point for all sprites (0,0 = top-left, 0.5,0.5 = center, 1,1 = bottom-right) public Vector2Data Pivot { get; set; } Property Value Vector2Data Rows Number of rows in the sprite sheet public int Rows { get; set; } Property Value int Spacing Spacing between sprites in pixels (default 0) public int Spacing { get; set; } Property Value int SpriteHeight Height of each sprite in pixels (for uniform grids) public int SpriteHeight { get; set; } Property Value int SpriteWidth Width of each sprite in pixels (for uniform grids) public int SpriteWidth { get; set; } Property Value int"
  },
  "api/Kobold.Core.Assets.Vector2Data.html": {
    "href": "api/Kobold.Core.Assets.Vector2Data.html",
    "title": "Class Vector2Data | Kobold Game Framework",
    "summary": "Class Vector2Data Namespace Kobold.Core.Assets Assembly Kobold.Core.dll Vector2 data for JSON serialization public class Vector2Data Inheritance object Vector2Data Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties X public float X { get; set; } Property Value float Y public float Y { get; set; } Property Value float Methods FromVector2(Vector2) public static Vector2Data FromVector2(Vector2 v) Parameters v Vector2 Returns Vector2Data ToVector2() public Vector2 ToVector2() Returns Vector2"
  },
  "api/Kobold.Core.Assets.html": {
    "href": "api/Kobold.Core.Assets.html",
    "title": "Namespace Kobold.Core.Assets | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Assets Classes AnimationData Animation configuration data RectangleData Rectangle data for JSON serialization SpriteSheet Represents a sprite sheet with its texture and configuration SpriteSheetConfig Configuration for how a sprite sheet should be divided Vector2Data Vector2 data for JSON serialization"
  },
  "api/Kobold.Core.Components.Acceleration.html": {
    "href": "api/Kobold.Core.Components.Acceleration.html",
    "title": "Struct Acceleration | Kobold Game Framework",
    "summary": "Struct Acceleration Namespace Kobold.Core.Components Assembly Kobold.Core.dll Acceleration component for entities that need forces applied over time public struct Acceleration Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Acceleration(Vector2) public Acceleration(Vector2 value) Parameters value Vector2 Acceleration(float, float) public Acceleration(float x, float y) Parameters x float y float Fields Value public Vector2 Value Field Value Vector2"
  },
  "api/Kobold.Core.Components.AngularAcceleration.html": {
    "href": "api/Kobold.Core.Components.AngularAcceleration.html",
    "title": "Struct AngularAcceleration | Kobold Game Framework",
    "summary": "Struct AngularAcceleration Namespace Kobold.Core.Components Assembly Kobold.Core.dll Angular acceleration component public struct AngularAcceleration Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors AngularAcceleration(float) public AngularAcceleration(float value) Parameters value float Fields Value public float Value Field Value float Methods FromDegrees(float) Create from degrees per second squared public static AngularAcceleration FromDegrees(float degreesPerSecondSquared) Parameters degreesPerSecondSquared float Returns AngularAcceleration"
  },
  "api/Kobold.Core.Components.AngularVelocity.html": {
    "href": "api/Kobold.Core.Components.AngularVelocity.html",
    "title": "Struct AngularVelocity | Kobold Game Framework",
    "summary": "Struct AngularVelocity Namespace Kobold.Core.Components Assembly Kobold.Core.dll Angular velocity component for rotating entities public struct AngularVelocity Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors AngularVelocity(float) public AngularVelocity(float value) Parameters value float Fields Value public float Value Field Value float Methods FromDegrees(float) Create angular velocity from degrees per second public static AngularVelocity FromDegrees(float degreesPerSecond) Parameters degreesPerSecond float Returns AngularVelocity GetDegrees() Get angular velocity in degrees per second public float GetDegrees() Returns float"
  },
  "api/Kobold.Core.Components.Animation.html": {
    "href": "api/Kobold.Core.Components.Animation.html",
    "title": "Struct Animation | Kobold Game Framework",
    "summary": "Struct Animation Namespace Kobold.Core.Components Assembly Kobold.Core.dll Component that manages sprite animation state public struct Animation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Animation(Dictionary<string, AnimationClip>, string) public Animation(Dictionary<string, AnimationClip> clips, string initialClip = \"\") Parameters clips Dictionary<string, AnimationClip> initialClip string Fields Clips public Dictionary<string, AnimationClip> Clips Field Value Dictionary<string, AnimationClip> CurrentClip public string CurrentClip Field Value string CurrentFrame public int CurrentFrame Field Value int IsPlaying public bool IsPlaying Field Value bool TimeInCurrentFrame public float TimeInCurrentFrame Field Value float Methods GetCurrentClip() Get the current animation clip public readonly AnimationClip? GetCurrentClip() Returns AnimationClip GetCurrentFrameRect() Get the current frame rectangle for rendering public readonly Rectangle GetCurrentFrameRect() Returns Rectangle Play(string, bool) Play a specific animation clip public void Play(string clipName, bool restart = false) Parameters clipName string restart bool"
  },
  "api/Kobold.Core.Components.AnimationClip.html": {
    "href": "api/Kobold.Core.Components.AnimationClip.html",
    "title": "Class AnimationClip | Kobold Game Framework",
    "summary": "Class AnimationClip Namespace Kobold.Core.Components Assembly Kobold.Core.dll Defines a sequence of frames for an animation public class AnimationClip Inheritance object AnimationClip Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AnimationClip(string, Rectangle[], float, bool) public AnimationClip(string name, Rectangle[] frames, float frameDuration, bool loop = true) Parameters name string frames Rectangle[] frameDuration float loop bool Properties FrameDuration public float FrameDuration { get; set; } Property Value float Frames public Rectangle[] Frames { get; set; } Property Value Rectangle[] Loop public bool Loop { get; set; } Property Value bool Name public string Name { get; set; } Property Value string Methods FromGrid(string, int, int, int, int, int, int, float, bool) Helper to create an animation from a sprite sheet grid public static AnimationClip FromGrid(string name, int startRow, int startCol, int rows, int cols, int frameWidth, int frameHeight, float frameDuration, bool loop = true) Parameters name string startRow int startCol int rows int cols int frameWidth int frameHeight int frameDuration float loop bool Returns AnimationClip FromSpriteSheet(string, int, int, int, int, int, float, bool) Helper to create an animation from a sprite sheet with uniform frame sizes public static AnimationClip FromSpriteSheet(string name, int startX, int startY, int frameWidth, int frameHeight, int frameCount, float frameDuration, bool loop = true) Parameters name string startX int startY int frameWidth int frameHeight int frameCount int frameDuration float loop bool Returns AnimationClip"
  },
  "api/Kobold.Core.Components.BoxCollider.html": {
    "href": "api/Kobold.Core.Components.BoxCollider.html",
    "title": "Struct BoxCollider | Kobold Game Framework",
    "summary": "Struct BoxCollider Namespace Kobold.Core.Components Assembly Kobold.Core.dll Component defining a rectangular collision boundary for an entity. This creates an axis-aligned bounding box (AABB) used by collision detection systems to determine when entities are overlapping or touching. The collision box is positioned relative to the entity's Transform.Position, with an optional offset to fine-tune the collision area. The box doesn't rotate with the entity - it's always axis-aligned for performance. public struct BoxCollider Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BoxCollider(Vector2, Vector2) Creates a new BoxCollider with the specified size and optional offset. public BoxCollider(Vector2 size, Vector2 offset = default) Parameters size Vector2 Width and height of the collision box in pixels offset Vector2 Offset from entity position to collision box (default: 0,0) BoxCollider(float, float, Vector2) Creates a new BoxCollider with the specified width, height, and optional offset. Convenience constructor for when you have separate width and height values. public BoxCollider(float width, float height, Vector2 offset = default) Parameters width float Width of the collision box in pixels height float Height of the collision box in pixels offset Vector2 Offset from entity position to collision box (default: 0,0) Fields Offset Offset from the entity's Transform.Position to the collision box's top-left corner. This allows fine-tuning the collision area relative to the entity's logical position. X component: Horizontal offset in pixels (positive = right, negative = left) Y component: Vertical offset in pixels (positive = down, negative = up) Common uses: (0, 0) = collision box starts at entity position (default) (-Size.X/2, -Size.Y/2) = center the collision box on the entity position (5, 10) = move collision box 5 pixels right and 10 pixels down from entity position Useful when the entity's Transform.Position represents the center, but you want the collision box positioned differently, or when the visual sprite doesn't perfectly match the collision area you want. public Vector2 Offset Field Value Vector2 Size The width and height of the collision box in pixels. X component: Width of the collision box Y component: Height of the collision box This defines the collision area regardless of any visual scaling or rotation. Should match the logical size of the entity for collision purposes. Examples: (20, 20) = 20x20 pixel square collision box (50, 10) = 50 pixels wide, 10 pixels tall (like a paddle) (5, 100) = 5 pixels wide, 100 pixels tall (like a thin laser beam) Values should be positive. Zero or negative values may cause undefined behavior in collision detection systems. public Vector2 Size Field Value Vector2 Methods Contains(Vector2, Vector2) Checks if a world point is inside this collision box. public readonly bool Contains(Vector2 entityPosition, Vector2 point) Parameters entityPosition Vector2 The entity's Transform.Position point Vector2 World point to test Returns bool True if the point is inside the collision box FromRenderSize(Vector2, bool) Creates a BoxCollider that matches the size of a rendered rectangle. Useful when you want collision to exactly match the visual representation. public static BoxCollider FromRenderSize(Vector2 renderSize, bool centered = false) Parameters renderSize Vector2 Size of the rendered rectangle centered bool If true, centers the collision box on the entity position Returns BoxCollider BoxCollider matching the render size GetWorldBounds(Vector2) Gets the world-space bounds of this collision box. Returns the left, top, right, and bottom edges in world coordinates. public readonly (float left, float top, float right, float bottom) GetWorldBounds(Vector2 entityPosition) Parameters entityPosition Vector2 The entity's Transform.Position Returns (float left, float top, float right, float bottom) Tuple of (left, top, right, bottom) world coordinates GetWorldCenter(Vector2) Gets the center point of the collision box in world coordinates. public readonly Vector2 GetWorldCenter(Vector2 entityPosition) Parameters entityPosition Vector2 The entity's Transform.Position Returns Vector2 World position of the collision box center GetWorldPosition(Vector2) Gets the actual world position of the collision box's top-left corner. This combines the entity's transform position with the collider's offset. public readonly Vector2 GetWorldPosition(Vector2 entityPosition) Parameters entityPosition Vector2 The entity's Transform.Position Returns Vector2 World position of the collision box's top-left corner Overlaps(Vector2, BoxCollider, Vector2) Checks if this collision box overlaps with another collision box. Both boxes are positioned using their respective entity positions. public readonly bool Overlaps(Vector2 entityPosition, BoxCollider other, Vector2 otherEntityPosition) Parameters entityPosition Vector2 This entity's Transform.Position other BoxCollider The other collision box otherEntityPosition Vector2 The other entity's Transform.Position Returns bool True if the collision boxes overlap Shrunken(Vector2, float, bool) Creates a BoxCollider slightly smaller than the render size. Useful for making collisions feel more forgiving in games. public static BoxCollider Shrunken(Vector2 renderSize, float shrinkAmount, bool centered = false) Parameters renderSize Vector2 Size of the rendered rectangle shrinkAmount float Amount to shrink the collision box on all sides centered bool If true, centers the collision box on the entity position Returns BoxCollider Shrunken BoxCollider Square(float, bool) Creates a square BoxCollider with the specified size. public static BoxCollider Square(float size, bool centered = false) Parameters size float Width and height of the square collision box centered bool If true, centers the collision box on the entity position Returns BoxCollider Square BoxCollider ToString() Returns a human-readable string representation of this collision box. Useful for debugging and logging. public override readonly string ToString() Returns string"
  },
  "api/Kobold.Core.Components.Camera.html": {
    "href": "api/Kobold.Core.Components.Camera.html",
    "title": "Struct Camera | Kobold Game Framework",
    "summary": "Struct Camera Namespace Kobold.Core.Components Assembly Kobold.Core.dll Camera component that defines the viewport and follows a target. When present, the RenderSystem will automatically transform world coordinates to screen coordinates. public struct Camera Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Camera(float, float, float) public Camera(float viewportWidth, float viewportHeight, float smoothSpeed = 5) Parameters viewportWidth float viewportHeight float smoothSpeed float Fields FollowTarget public bool FollowTarget Field Value bool MaxBounds public Vector2 MaxBounds Field Value Vector2 MinBounds public Vector2 MinBounds Field Value Vector2 Position public Vector2 Position Field Value Vector2 SmoothSpeed public float SmoothSpeed Field Value float ViewportHeight public float ViewportHeight Field Value float ViewportWidth public float ViewportWidth Field Value float Methods GetViewportBounds() Gets the camera's viewport bounds in world space. public readonly (float left, float top, float right, float bottom) GetViewportBounds() Returns (float left, float top, float right, float bottom) ScreenToWorld(Vector2) Converts screen position to world position. public readonly Vector2 ScreenToWorld(Vector2 screenPosition) Parameters screenPosition Vector2 Returns Vector2 SetBounds(float, float) Sets the camera bounds based on the map size. public void SetBounds(float mapWidth, float mapHeight) Parameters mapWidth float mapHeight float WorldToScreen(Vector2) Converts world position to screen position. public readonly Vector2 WorldToScreen(Vector2 worldPosition) Parameters worldPosition Vector2 Returns Vector2"
  },
  "api/Kobold.Core.Components.CoreGameState.html": {
    "href": "api/Kobold.Core.Components.CoreGameState.html",
    "title": "Struct CoreGameState | Kobold Game Framework",
    "summary": "Struct CoreGameState Namespace Kobold.Core.Components Assembly Kobold.Core.dll Convenience wrapper for games that use the standard core game states. This provides a simpler API than the full generic GameState<TState> for common cases. Most simple games can just use this instead of defining their own state enum. public struct CoreGameState : IEquatable<CoreGameState> Implements IEquatable<CoreGameState> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CoreGameState(StandardGameState, string, Dictionary<string, object>) public CoreGameState(StandardGameState state, string message = \"\", Dictionary<string, object> stateData = null) Parameters state StandardGameState message string stateData Dictionary<string, object> Properties IsGameOver public readonly bool IsGameOver { get; } Property Value bool IsInMenu public readonly bool IsInMenu { get; } Property Value bool IsLoading public readonly bool IsLoading { get; } Property Value bool IsPaused public readonly bool IsPaused { get; } Property Value bool IsPlaying public readonly bool IsPlaying { get; } Property Value bool Message public string Message { get; } Property Value string State public StandardGameState State { get; } Property Value StandardGameState StateData public Dictionary<string, object> StateData { get; } Property Value Dictionary<string, object> StateEnteredAt public DateTime StateEnteredAt { get; } Property Value DateTime Methods Equals(CoreGameState) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(CoreGameState other) Parameters other CoreGameState An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetStateData<T>(string) public readonly T GetStateData<T>(string key) Parameters key string Returns T Type Parameters T GetTimeInState() public readonly TimeSpan GetTimeInState() Returns TimeSpan SetStateData(string, object) public void SetStateData(string key, object value) Parameters key string value object ToDetailedString() public readonly string ToDetailedString() Returns string ToString() Returns the fully qualified type name of this instance. public override readonly string ToString() Returns string The fully qualified type name. WithMessage(string) public readonly CoreGameState WithMessage(string newMessage) Parameters newMessage string Returns CoreGameState WithState(StandardGameState, string) public readonly CoreGameState WithState(StandardGameState newState, string newMessage = null) Parameters newState StandardGameState newMessage string Returns CoreGameState Operators operator ==(CoreGameState, CoreGameState) public static bool operator ==(CoreGameState left, CoreGameState right) Parameters left CoreGameState right CoreGameState Returns bool implicit operator StandardGameState(CoreGameState) public static implicit operator StandardGameState(CoreGameState gameState) Parameters gameState CoreGameState Returns StandardGameState implicit operator CoreGameState(StandardGameState) public static implicit operator CoreGameState(StandardGameState state) Parameters state StandardGameState Returns CoreGameState operator !=(CoreGameState, CoreGameState) public static bool operator !=(CoreGameState left, CoreGameState right) Parameters left CoreGameState right CoreGameState Returns bool"
  },
  "api/Kobold.Core.Components.Debug.html": {
    "href": "api/Kobold.Core.Components.Debug.html",
    "title": "Struct Debug | Kobold Game Framework",
    "summary": "Struct Debug Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as debug/development-only content. Used by systems to show diagnostic information, development tools, or testing content that should be hidden in production builds. Examples: RenderSystem: Only renders Debug entities in development builds InputSystem: Debug entities might respond to special key combinations LoggingSystem: Extra verbose logging for Debug entities ProfilerSystem: Performance monitoring for Debug entities Debug entities might include: Collision visualization (showing hitboxes) Performance counters and framerate displays AI pathfinding visualization Physics force indicators Entity inspector tools Cheat/testing controls Should be easily disabled for release builds via preprocessor directives or build configuration flags. public struct Debug Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.Destructible.html": {
    "href": "api/Kobold.Core.Components.Destructible.html",
    "title": "Struct Destructible | Kobold Game Framework",
    "summary": "Struct Destructible Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as destructible environment. Used by systems to handle breakable objects that can be damaged but aren't enemies (don't move, don't fight back). Examples: CollisionSystem: Takes damage from projectiles/explosions HealthSystem: Has hit points and can be destroyed EffectSystem: Shows damage effects, debris when destroyed ScoringSystem: May award points when destroyed Destructible entities typically also have: Health component (hit points) Collider (for damage detection) DropTable (what items spawn when destroyed) Examples: crates, barrels, walls, barriers, destructible terrain This is different from Static (can't be damaged) and Enemy (actively hostile). public struct Destructible Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.DestructionReason.html": {
    "href": "api/Kobold.Core.Components.DestructionReason.html",
    "title": "Enum DestructionReason | Kobold Game Framework",
    "summary": "Enum DestructionReason Namespace Kobold.Core.Components Assembly Kobold.Core.dll public enum DestructionReason Fields BoundaryExit = 0 Collision = 1 GameRestart = 4 Lifetime = 2 Manual = 3"
  },
  "api/Kobold.Core.Components.Drag.html": {
    "href": "api/Kobold.Core.Components.Drag.html",
    "title": "Struct Drag | Kobold Game Framework",
    "summary": "Struct Drag Namespace Kobold.Core.Components Assembly Kobold.Core.dll Drag/friction component for air/space resistance public struct Drag Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Drag(float, float) public Drag(float linear, float angular = 0) Parameters linear float angular float Fields Angular public float Angular Field Value float Linear public float Linear Field Value float Properties Atmosphere Atmosphere-like drag (more noticeable) public static Drag Atmosphere { get; } Property Value Drag Space Space-like drag (very minimal) public static Drag Space { get; } Property Value Drag Water Water-like drag (heavy) public static Drag Water { get; } Property Value Drag"
  },
  "api/Kobold.Core.Components.Dynamic.html": {
    "href": "api/Kobold.Core.Components.Dynamic.html",
    "title": "Struct Dynamic | Kobold Game Framework",
    "summary": "Struct Dynamic Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as movable/physics-affected. Opposite of Static - indicates this entity should be processed by movement, physics, and dynamic collision systems. Examples: PhysicsSystem: Applies velocity, acceleration, and forces CollisionSystem: Full collision detection and response BoundarySystem: Handles boundary collisions (wrap, clamp, bounce) AISystem: Updates movement for dynamic AI entities Most game entities are Dynamic: Players, enemies, NPCs Projectiles, particles Moving platforms, elevators Physics objects like crates, balls Note: You don't usually need both Static and Dynamic tags in the same game. Choose one approach - either tag the minority case, or use presence/absence of Physics components. public struct Dynamic Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.Enemy.html": {
    "href": "api/Kobold.Core.Components.Enemy.html",
    "title": "Struct Enemy | Kobold Game Framework",
    "summary": "Struct Enemy Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as an enemy/hostile unit. Used by systems to identify entities that should attack the player, be targeted by player weapons, or follow enemy-specific behavior patterns. Examples: AISystem: Entities with Enemy tag use hostile AI behaviors CollisionSystem: Enemy vs Player projectile collision detection ScoringSystem: Award points when Enemy entities are destroyed FormationSystem: Enemy entities move in coordinated patterns SpawningSystem: Creates entities with Enemy tag during waves Often combined with other components like Health, Weapon, AIBehavior to create complete enemy entities with different capabilities. public struct Enemy Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.GameState-1.html": {
    "href": "api/Kobold.Core.Components.GameState-1.html",
    "title": "Struct GameState<TState> | Kobold Game Framework",
    "summary": "Struct GameState<TState> Namespace Kobold.Core.Components Assembly Kobold.Core.dll Core game state component that represents the current high-level state of the game. This is used by the SystemManager to determine which systems should be active, and by game-specific systems to control flow and behavior. The core engine provides basic states (Playing, Paused, GameOver), but games can extend this with their own state enums by implementing IGameState. Only one GameState component should exist per game - it's typically attached to a singleton entity that represents the overall game session. public struct GameState<TState> : IEquatable<GameState<TState>> where TState : struct, Enum Type Parameters TState The state enum type (e.g., PongGameState, SpaceInvadersState) Implements IEquatable<GameState<TState>> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors GameState(TState, string, Dictionary<string, object>) Creates a new GameState with the specified state and optional message. public GameState(TState state, string message = \"\", Dictionary<string, object> stateData = null) Parameters state TState The game state enum value message string Optional descriptive message stateData Dictionary<string, object> Optional additional state data Properties Message Optional message associated with the current state. Examples: \"Player 1 Wins!\" for GameOver state \"Wave 3 Starting...\" for Playing state \"Game Paused\" for Paused state Used primarily by UI systems for displaying state-specific text. public string Message { readonly get; set; } Property Value string State The current state of the game. This determines which systems are active and how the game behaves. For example: Playing: All gameplay systems active Paused: Only UI and input systems active GameOver: Only UI systems active, waiting for restart public TState State { readonly get; set; } Property Value TState StateData Additional contextual data for the current state. This is a flexible dictionary for state-specific information that doesn't warrant its own field. Examples: \"WinningPlayerId\" -> \"1\" for GameOver state \"WaveNumber\" -> \"5\" for Playing state \"PauseReason\" -> \"PlayerInput\" vs \"LostFocus\" for Paused state public Dictionary<string, object> StateData { readonly get; set; } Property Value Dictionary<string, object> StateEnteredAt Timestamp when this state was entered. Useful for tracking how long the game has been in a particular state, implementing time-based state transitions, or analytics. public DateTime StateEnteredAt { readonly get; set; } Property Value DateTime Methods Equals(GameState<TState>) Indicates whether the current object is equal to another object of the same type. public readonly bool Equals(GameState<TState> other) Parameters other GameState<TState> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Indicates whether this instance and a specified object are equal. public override readonly bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override readonly int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetStateData<T>(string) Gets a typed value from the StateData dictionary. Returns the default value for the type if the key doesn't exist or can't be cast. public readonly T GetStateData<T>(string key) Parameters key string The key to look up Returns T The typed value or default(T) Type Parameters T The type to cast the value to GetTimeInState() Gets how long the game has been in this current state. public readonly TimeSpan GetTimeInState() Returns TimeSpan Time elapsed since entering this state SetStateData(string, object) Sets a value in the StateData dictionary. public void SetStateData(string key, object value) Parameters key string The key to set value object The value to store ToDetailedString() Returns a detailed string representation including message and state data. Useful for debugging and detailed logging. public readonly string ToDetailedString() Returns string ToString() Returns the state as a string for debugging and logging. Only uses the State enum for string representation to ensure consistency. public override readonly string ToString() Returns string WithMessage(string) Creates a new GameState with updated message but same state. public readonly GameState<TState> WithMessage(string newMessage) Parameters newMessage string The new message Returns GameState<TState> New GameState with updated message WithState(TState, string) Creates a new GameState with a different state but preserving other data. Useful for state transitions where you want to keep context. public readonly GameState<TState> WithState(TState newState, string newMessage = null) Parameters newState TState The new state to transition to newMessage string Optional new message (null keeps current message) Returns GameState<TState> New GameState with updated state Operators operator ==(GameState<TState>, GameState<TState>) public static bool operator ==(GameState<TState> left, GameState<TState> right) Parameters left GameState<TState> right GameState<TState> Returns bool operator !=(GameState<TState>, GameState<TState>) public static bool operator !=(GameState<TState> left, GameState<TState> right) Parameters left GameState<TState> right GameState<TState> Returns bool"
  },
  "api/Kobold.Core.Components.Gameplay.CustomBoundaryBehavior.html": {
    "href": "api/Kobold.Core.Components.Gameplay.CustomBoundaryBehavior.html",
    "title": "Struct CustomBoundaryBehavior | Kobold Game Framework",
    "summary": "Struct CustomBoundaryBehavior Namespace Kobold.Core.Components.Gameplay Assembly Kobold.Core.dll Component that allows an entity to have custom boundary behavior that overrides the default public struct CustomBoundaryBehavior Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CustomBoundaryBehavior(BoundaryBehavior) public CustomBoundaryBehavior(BoundaryBehavior behavior) Parameters behavior BoundaryBehavior Fields Behavior public BoundaryBehavior Behavior Field Value BoundaryBehavior"
  },
  "api/Kobold.Core.Components.Gameplay.Lifetime.html": {
    "href": "api/Kobold.Core.Components.Gameplay.Lifetime.html",
    "title": "Struct Lifetime | Kobold Game Framework",
    "summary": "Struct Lifetime Namespace Kobold.Core.Components.Gameplay Assembly Kobold.Core.dll public struct Lifetime Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Lifetime(float) public Lifetime(float lifetime) Parameters lifetime float Fields RemainingTime public float RemainingTime Field Value float"
  },
  "api/Kobold.Core.Components.Gameplay.html": {
    "href": "api/Kobold.Core.Components.Gameplay.html",
    "title": "Namespace Kobold.Core.Components.Gameplay | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Components.Gameplay Structs CustomBoundaryBehavior Component that allows an entity to have custom boundary behavior that overrides the default Lifetime"
  },
  "api/Kobold.Core.Components.Gravity.html": {
    "href": "api/Kobold.Core.Components.Gravity.html",
    "title": "Struct Gravity | Kobold Game Framework",
    "summary": "Struct Gravity Namespace Kobold.Core.Components Assembly Kobold.Core.dll Adds gravity to an entity public struct Gravity Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Gravity(Vector2) public Gravity(Vector2 force) Parameters force Vector2 Gravity(float, float) public Gravity(float x, float y) Parameters x float y float Fields Force public Vector2 Force Field Value Vector2 Methods Down(float) public static Gravity Down(float strength = 981) Parameters strength float Returns Gravity Left(float) public static Gravity Left(float strength = 981) Parameters strength float Returns Gravity Right(float) public static Gravity Right(float strength = 981) Parameters strength float Returns Gravity Up(float) public static Gravity Up(float strength = 981) Parameters strength float Returns Gravity"
  },
  "api/Kobold.Core.Components.IRenderable.html": {
    "href": "api/Kobold.Core.Components.IRenderable.html",
    "title": "Interface IRenderable | Kobold Game Framework",
    "summary": "Interface IRenderable Namespace Kobold.Core.Components Assembly Kobold.Core.dll public interface IRenderable Properties Layer int Layer { get; } Property Value int"
  },
  "api/Kobold.Core.Components.MaxSpeed.html": {
    "href": "api/Kobold.Core.Components.MaxSpeed.html",
    "title": "Struct MaxSpeed | Kobold Game Framework",
    "summary": "Struct MaxSpeed Namespace Kobold.Core.Components Assembly Kobold.Core.dll Maximum speed constraint for entities public struct MaxSpeed Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors MaxSpeed(float) public MaxSpeed(float value) Parameters value float Fields Value public float Value Field Value float"
  },
  "api/Kobold.Core.Components.PendingDestruction.html": {
    "href": "api/Kobold.Core.Components.PendingDestruction.html",
    "title": "Struct PendingDestruction | Kobold Game Framework",
    "summary": "Struct PendingDestruction Namespace Kobold.Core.Components Assembly Kobold.Core.dll Component to mark entities for destruction at the end of the frame This prevents mid-frame destruction issues with collision detection public struct PendingDestruction Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PendingDestruction(DestructionReason, float) public PendingDestruction(DestructionReason reason, float delay = 0) Parameters reason DestructionReason delay float Fields Reason public DestructionReason Reason Field Value DestructionReason TimeRemaining public float TimeRemaining Field Value float"
  },
  "api/Kobold.Core.Components.Physics.html": {
    "href": "api/Kobold.Core.Components.Physics.html",
    "title": "Struct Physics | Kobold Game Framework",
    "summary": "Struct Physics Namespace Kobold.Core.Components Assembly Kobold.Core.dll Enhanced physics properties public struct Physics Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Physics(float, float, bool, float) public Physics(float mass = 1, float damping = 0, bool isStatic = false, float restitution = 0) Parameters mass float damping float isStatic bool restitution float Fields Damping public float Damping Field Value float IsStatic public bool IsStatic Field Value bool Mass public float Mass Field Value float Restitution public float Restitution Field Value float Properties Heavy Heavy object (harder to move) public static Physics Heavy { get; } Property Value Physics Light Light object (moves easily) public static Physics Light { get; } Property Value Physics Static Static object (infinite mass, doesn't move) public static Physics Static { get; } Property Value Physics"
  },
  "api/Kobold.Core.Components.Player.html": {
    "href": "api/Kobold.Core.Components.Player.html",
    "title": "Struct Player | Kobold Game Framework",
    "summary": "Struct Player Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as player-controlled. Used by systems to identify which entities should respond to player input, be affected by player-specific rules, or be treated specially by AI. Examples: InputSystem: Only moves entities with Player tag CameraSystem: Follows entities with Player tag CollisionSystem: Player vs Enemy collision rules UISystem: Updates health bars for Player entities In multiplayer games, you might have Player1, Player2 tags instead, or use a PlayerID component for more complex player management. public struct Player Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.PlayerControlled.html": {
    "href": "api/Kobold.Core.Components.PlayerControlled.html",
    "title": "Struct PlayerControlled | Kobold Game Framework",
    "summary": "Struct PlayerControlled Namespace Kobold.Core.Components Assembly Kobold.Core.dll Component for entities controlled by player input public struct PlayerControlled Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PlayerControlled(float, bool, bool, KeyCode, KeyCode, KeyCode, KeyCode, KeyCode, KeyCode, KeyCode, KeyCode) public PlayerControlled(float speed, bool verticalOnly = false, bool horizontalOnly = false, KeyCode up = KeyCode.Up, KeyCode down = KeyCode.Down, KeyCode left = KeyCode.Left, KeyCode right = KeyCode.Right, KeyCode altUp = KeyCode.W, KeyCode altDown = KeyCode.S, KeyCode altLeft = KeyCode.A, KeyCode altRight = KeyCode.D) Parameters speed float verticalOnly bool horizontalOnly bool up KeyCode down KeyCode left KeyCode right KeyCode altUp KeyCode altDown KeyCode altLeft KeyCode altRight KeyCode Fields AlternateDownKey public KeyCode AlternateDownKey Field Value KeyCode AlternateLeftKey public KeyCode AlternateLeftKey Field Value KeyCode AlternateRightKey public KeyCode AlternateRightKey Field Value KeyCode AlternateUpKey public KeyCode AlternateUpKey Field Value KeyCode DownKey public KeyCode DownKey Field Value KeyCode HorizontalOnly public bool HorizontalOnly Field Value bool LeftKey public KeyCode LeftKey Field Value KeyCode RightKey public KeyCode RightKey Field Value KeyCode Speed public float Speed Field Value float UpKey public KeyCode UpKey Field Value KeyCode VerticalOnly public bool VerticalOnly Field Value bool Methods CreateHorizontalOnly(float, KeyCode, KeyCode, KeyCode, KeyCode) public static PlayerControlled CreateHorizontalOnly(float speed, KeyCode left = KeyCode.Left, KeyCode right = KeyCode.Right, KeyCode altLeft = KeyCode.A, KeyCode altRight = KeyCode.D) Parameters speed float left KeyCode right KeyCode altLeft KeyCode altRight KeyCode Returns PlayerControlled CreateVerticalOnly(float, KeyCode, KeyCode, KeyCode, KeyCode) public static PlayerControlled CreateVerticalOnly(float speed, KeyCode up = KeyCode.Up, KeyCode down = KeyCode.Down, KeyCode altUp = KeyCode.W, KeyCode altDown = KeyCode.S) Parameters speed float up KeyCode down KeyCode altUp KeyCode altDown KeyCode Returns PlayerControlled FullMovement(float) public static PlayerControlled FullMovement(float speed) Parameters speed float Returns PlayerControlled"
  },
  "api/Kobold.Core.Components.PowerUp.html": {
    "href": "api/Kobold.Core.Components.PowerUp.html",
    "title": "Struct PowerUp | Kobold Game Framework",
    "summary": "Struct PowerUp Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as a collectible power-up or item. Used by systems to handle pickup mechanics, temporary effects, and inventory management. Examples: CollisionSystem: Player touching PowerUp triggers collection EffectSystem: Applies temporary bonuses when collected ScoringSystem: Awards points for collecting power-ups SpawningSystem: Creates PowerUp entities at specific locations/times RenderSystem: PowerUps might pulse, glow, or rotate for visibility PowerUp entities typically also have: PowerUpType component (what effect it provides) EffectDuration (how long the bonus lasts) CollectionValue (points awarded) Lifetime (despawn if not collected) Examples: health packs, weapon upgrades, speed boosts, shields, extra lives public struct PowerUp Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.Projectile.html": {
    "href": "api/Kobold.Core.Components.Projectile.html",
    "title": "Struct Projectile | Kobold Game Framework",
    "summary": "Struct Projectile Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as a projectile (bullet, missile, laser, etc.). Used by systems to apply projectile-specific behaviors like automatic movement, collision damage, and lifetime management. Examples: CollisionSystem: Projectiles damage targets and may be destroyed on impact BoundarySystem: Projectiles are usually destroyed when leaving screen bounds LifetimeSystem: Projectiles often have limited range/duration PhysicsSystem: Projectiles may ignore certain physics (like gravity) RenderSystem: Projectiles might use additive blending or special effects Projectile entities typically also have: Velocity (for movement) Lifetime (for range limiting) Damage (for collision effects) Owner (to prevent self-damage) Different projectile types can be distinguished using additional components or by having specific projectile tags (PlayerProjectile, EnemyProjectile). public struct Projectile Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.RectangleRenderer.html": {
    "href": "api/Kobold.Core.Components.RectangleRenderer.html",
    "title": "Struct RectangleRenderer | Kobold Game Framework",
    "summary": "Struct RectangleRenderer Namespace Kobold.Core.Components Assembly Kobold.Core.dll public struct RectangleRenderer : IRenderable Implements IRenderable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RectangleRenderer(Vector2, Color, int) public RectangleRenderer(Vector2 size, Color color, int layer = 0) Parameters size Vector2 color Color layer int Fields Color public Color Color Field Value Color Size public Vector2 Size Field Value Vector2 Properties Layer public readonly int Layer { get; } Property Value int Methods Background(Vector2, Color) public static RectangleRenderer Background(Vector2 size, Color color) Parameters size Vector2 color Color Returns RectangleRenderer GameObject(Vector2, Color) public static RectangleRenderer GameObject(Vector2 size, Color color) Parameters size Vector2 color Color Returns RectangleRenderer UI(Vector2, Color) public static RectangleRenderer UI(Vector2 size, Color color) Parameters size Vector2 color Color Returns RectangleRenderer"
  },
  "api/Kobold.Core.Components.RenderLayers.html": {
    "href": "api/Kobold.Core.Components.RenderLayers.html",
    "title": "Class RenderLayers | Kobold Game Framework",
    "summary": "Class RenderLayers Namespace Kobold.Core.Components Assembly Kobold.Core.dll Standard rendering layer values Lower values render first (behind), higher values render last (on top) public static class RenderLayers Inheritance object RenderLayers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Background public const int Background = -100 Field Value int Debug public const int Debug = 1000 Field Value int Effects public const int Effects = 50 Field Value int GameObjects public const int GameObjects = 0 Field Value int UI public const int UI = 100 Field Value int"
  },
  "api/Kobold.Core.Components.ScreenBounds.html": {
    "href": "api/Kobold.Core.Components.ScreenBounds.html",
    "title": "Struct ScreenBounds | Kobold Game Framework",
    "summary": "Struct ScreenBounds Namespace Kobold.Core.Components Assembly Kobold.Core.dll public struct ScreenBounds Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ScreenBounds(float, float) public ScreenBounds(float width, float height) Parameters width float height float Fields Height public float Height Field Value float Width public float Width Field Value float"
  },
  "api/Kobold.Core.Components.SpriteRenderer.html": {
    "href": "api/Kobold.Core.Components.SpriteRenderer.html",
    "title": "Struct SpriteRenderer | Kobold Game Framework",
    "summary": "Struct SpriteRenderer Namespace Kobold.Core.Components Assembly Kobold.Core.dll Renders a sprite from a texture or sprite sheet public struct SpriteRenderer : IRenderable Implements IRenderable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SpriteRenderer(ITexture, Rectangle, Vector2, float, Color?, int, Vector2?) public SpriteRenderer(ITexture texture, Rectangle sourceRect, Vector2 scale, float rotation = 0, Color? tint = null, int layer = 0, Vector2? pivot = null) Parameters texture ITexture sourceRect Rectangle scale Vector2 rotation float tint Color? layer int pivot Vector2? Fields Pivot public Vector2 Pivot Field Value Vector2 Rotation public float Rotation Field Value float Scale public Vector2 Scale Field Value Vector2 SourceRect public Rectangle SourceRect Field Value Rectangle Texture public ITexture Texture Field Value ITexture Tint public Color Tint Field Value Color Properties Layer public readonly int Layer { get; } Property Value int Methods Background(ITexture, Rectangle, Vector2) public static SpriteRenderer Background(ITexture texture, Rectangle sourceRect, Vector2 scale) Parameters texture ITexture sourceRect Rectangle scale Vector2 Returns SpriteRenderer FromSpriteSheet(ITexture, Rectangle, Vector2, float, Color?, int) Create a sprite renderer for a single frame from a sprite sheet public static SpriteRenderer FromSpriteSheet(ITexture texture, Rectangle sourceRect, Vector2 scale, float rotation = 0, Color? tint = null, int layer = 0) Parameters texture ITexture sourceRect Rectangle scale Vector2 rotation float tint Color? layer int Returns SpriteRenderer FullTexture(ITexture, Vector2, float, Color?, int) Create a sprite renderer for a full texture (not from a sprite sheet) public static SpriteRenderer FullTexture(ITexture texture, Vector2 scale, float rotation = 0, Color? tint = null, int layer = 0) Parameters texture ITexture scale Vector2 rotation float tint Color? layer int Returns SpriteRenderer GameObject(ITexture, Rectangle, Vector2) public static SpriteRenderer GameObject(ITexture texture, Rectangle sourceRect, Vector2 scale) Parameters texture ITexture sourceRect Rectangle scale Vector2 Returns SpriteRenderer UI(ITexture, Rectangle, Vector2) public static SpriteRenderer UI(ITexture texture, Rectangle sourceRect, Vector2 scale) Parameters texture ITexture sourceRect Rectangle scale Vector2 Returns SpriteRenderer"
  },
  "api/Kobold.Core.Components.StandardGameState.html": {
    "href": "api/Kobold.Core.Components.StandardGameState.html",
    "title": "Enum StandardGameState | Kobold Game Framework",
    "summary": "Enum StandardGameState Namespace Kobold.Core.Components Assembly Kobold.Core.dll Standard game states that most games will need. Games can use this directly or create their own enum with these values included. public enum StandardGameState Fields GameOver = 2 Game session has ended (win/lose condition met). Only UI systems should be active to show final state and restart options. Game world state may be reset or preserved for restart. Loading = 3 Game is loading resources or initializing. Typically only loading/progress systems are active. Transitions to Playing when ready. Menu = 4 Showing main menu or game selection screens. Only UI and menu systems are active. No gameplay systems should run. Paused = 1 Game is temporarily stopped but can be resumed. Only UI and input systems should be active to handle unpause input. Game world state is preserved. Playing = 0 Game is actively running - all gameplay systems should be active. This is the main game loop state where players can interact and things happen."
  },
  "api/Kobold.Core.Components.Static.html": {
    "href": "api/Kobold.Core.Components.Static.html",
    "title": "Struct Static | Kobold Game Framework",
    "summary": "Struct Static Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as non-moving/immovable. Used by physics and collision systems to optimize processing - static entities don't need velocity updates or complex collision resolution. Examples: PhysicsSystem: Skips velocity/acceleration updates for Static entities CollisionSystem: Uses simplified collision math (only other object moves) BoundarySystem: May skip boundary checking for Static entities RenderSystem: Can use different rendering optimizations for static sprites Common static entities: Walls, barriers, platforms Background decorations Fixed turrets or defensive structures UI elements positioned in world space public struct Static Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.TextRenderer.html": {
    "href": "api/Kobold.Core.Components.TextRenderer.html",
    "title": "Struct TextRenderer | Kobold Game Framework",
    "summary": "Struct TextRenderer Namespace Kobold.Core.Components Assembly Kobold.Core.dll public struct TextRenderer : IRenderable Implements IRenderable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors TextRenderer(string, Color, float, int) public TextRenderer(string text, Color color, float fontSize = 16, int layer = 100) Parameters text string color Color fontSize float layer int Fields Color public Color Color Field Value Color FontSize public float FontSize Field Value float Text public string Text Field Value string Properties Layer public readonly int Layer { get; } Property Value int Methods DebugText(string, Color, float) public static TextRenderer DebugText(string text, Color color, float fontSize = 12) Parameters text string color Color fontSize float Returns TextRenderer GameText(string, Color, float) public static TextRenderer GameText(string text, Color color, float fontSize = 16) Parameters text string color Color fontSize float Returns TextRenderer UIText(string, Color, float) public static TextRenderer UIText(string text, Color color, float fontSize = 16) Parameters text string color Color fontSize float Returns TextRenderer"
  },
  "api/Kobold.Core.Components.Thruster.html": {
    "href": "api/Kobold.Core.Components.Thruster.html",
    "title": "Struct Thruster | Kobold Game Framework",
    "summary": "Struct Thruster Namespace Kobold.Core.Components Assembly Kobold.Core.dll Thruster component for entities that can apply thrust public struct Thruster Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Thruster(float, bool) public Thruster(float power, bool isActive = false) Parameters power float isActive bool Fields IsActive public bool IsActive Field Value bool Power public float Power Field Value float"
  },
  "api/Kobold.Core.Components.Transform.html": {
    "href": "api/Kobold.Core.Components.Transform.html",
    "title": "Struct Transform | Kobold Game Framework",
    "summary": "Struct Transform Namespace Kobold.Core.Components Assembly Kobold.Core.dll Core component representing an entity's position, rotation, and scale in 2D world space. This is the fundamental spatial component that most other systems depend on - rendering, physics, collision detection, etc. all use Transform to determine where things are. Position is in world coordinates (pixels), rotation is in radians, and scale is a multiplier where Vector2.One (1,1) represents normal size. public struct Transform Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Transform(Vector2, float, Vector2) Creates a new Transform with the specified position, rotation, and scale. public Transform(Vector2 position, float rotation = 0, Vector2 scale = default) Parameters position Vector2 World position in pixels rotation float Rotation angle in radians (default: 0 = facing right) scale Vector2 Scale multiplier (default: Vector2.One = normal size) Transform(float, float) Creates a Transform at the specified position with default rotation and scale. Convenience constructor for the most common use case. public Transform(float x, float y) Parameters x float X coordinate in world space y float Y coordinate in world space Fields Position World position in 2D space, measured in pixels from the origin (0,0). Typically (0,0) represents the top-left corner of the screen, with X increasing to the right and Y increasing downward (standard screen coordinates). public Vector2 Position Field Value Vector2 Rotation Rotation angle in radians around the entity's center point. 0 radians = pointing right (+X direction) π/2 radians (90°) = pointing down (+Y direction) π radians (180°) = pointing left (-X direction) 3π/2 radians (270°) = pointing up (-Y direction) Used by rendering systems for sprite rotation and physics systems for directional movement. public float Rotation Field Value float Scale Scale multiplier for rendering and collision detection. Vector2.One (1,1) = normal size (2,2) = double size in both dimensions (0.5,0.5) = half size in both dimensions (1,2) = normal width, double height Affects both visual rendering and collision bounds. A scale of (0,0) would make the entity invisible and have no collision. public Vector2 Scale Field Value Vector2 Properties Forward Gets the forward direction vector based on the current rotation. This is useful for movement systems that need to move \"forward\" relative to rotation. public readonly Vector2 Forward { get; } Property Value Vector2 Normalized direction vector pointing in the rotation direction Identity Creates a Transform positioned at the world origin with default rotation and scale. public static Transform Identity { get; } Property Value Transform Right Gets the right direction vector based on the current rotation. Perpendicular to the forward direction, useful for strafing movement. public readonly Vector2 Right { get; } Property Value Vector2 Normalized direction vector pointing 90° clockwise from forward Methods AtPosition(Vector2) Creates a Transform at the specified position with default rotation and scale. public static Transform AtPosition(Vector2 position) Parameters position Vector2 World position Returns Transform Transform at the specified position AtPositionAndRotation(Vector2, float) Creates a Transform at the specified position with the specified rotation. public static Transform AtPositionAndRotation(Vector2 position, float rotationDegrees) Parameters position Vector2 World position rotationDegrees float Rotation in degrees Returns Transform Transform with position and rotation set GetRotationDegrees() Converts rotation from radians to degrees for debugging or display purposes. public readonly float GetRotationDegrees() Returns float Rotation angle in degrees LookAt(Vector2) Sets the rotation to point toward the specified target position. Useful for aiming mechanics or making entities face their movement direction. public void LookAt(Vector2 targetPosition) Parameters targetPosition Vector2 World position to face toward Rotate(float) Rotates the transform by the specified angle. public void Rotate(float deltaRotation) Parameters deltaRotation float Angle to rotate by, in radians SetRotationDegrees(float) Sets the rotation from degrees instead of radians. Convenience method for easier setup during development. public void SetRotationDegrees(float degrees) Parameters degrees float Rotation angle in degrees ToMatrix() Creates a transformation matrix representing this transform's position, rotation, and scale. Used by advanced rendering systems for GPU-accelerated transformations. public readonly Matrix4x4 ToMatrix() Returns Matrix4x4 4x4 transformation matrix for 2D graphics ToString() Returns a human-readable string representation of this transform. Useful for debugging and logging. public override readonly string ToString() Returns string Translate(Vector2) Moves the transform by the specified offset vector. public void Translate(Vector2 offset) Parameters offset Vector2 Distance to move in world coordinates Translate(float, float) Moves the transform by the specified distances. public void Translate(float deltaX, float deltaY) Parameters deltaX float Distance to move along X axis deltaY float Distance to move along Y axis"
  },
  "api/Kobold.Core.Components.TriangleRenderer.html": {
    "href": "api/Kobold.Core.Components.TriangleRenderer.html",
    "title": "Struct TriangleRenderer | Kobold Game Framework",
    "summary": "Struct TriangleRenderer Namespace Kobold.Core.Components Assembly Kobold.Core.dll Triangle renderer component public struct TriangleRenderer : IRenderable Implements IRenderable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors TriangleRenderer(Vector2, Vector2, Vector2, Color, int) public TriangleRenderer(Vector2 point1, Vector2 point2, Vector2 point3, Color color, int layer = 0) Parameters point1 Vector2 point2 Vector2 point3 Vector2 color Color layer int TriangleRenderer(Vector2[], Color, int) public TriangleRenderer(Vector2[] points, Color color, int layer = 0) Parameters points Vector2[] color Color layer int Fields Color public Color Color Field Value Color Points public Vector2[] Points Field Value Vector2[] Properties Layer public readonly int Layer { get; } Property Value int Methods GameObject(Vector2[], Color) public static TriangleRenderer GameObject(Vector2[] points, Color color) Parameters points Vector2[] color Color Returns TriangleRenderer PointingRight(float, float, Color, int) Create an isosceles triangle pointing right public static TriangleRenderer PointingRight(float width, float height, Color color, int layer = 0) Parameters width float height float color Color layer int Returns TriangleRenderer PointingUp(float, float, Color, int) Create an isosceles triangle pointing up public static TriangleRenderer PointingUp(float width, float height, Color color, int layer = 0) Parameters width float height float color Color layer int Returns TriangleRenderer UI(Vector2[], Color) public static TriangleRenderer UI(Vector2[] points, Color color) Parameters points Vector2[] color Color Returns TriangleRenderer"
  },
  "api/Kobold.Core.Components.Trigger.html": {
    "href": "api/Kobold.Core.Components.Trigger.html",
    "title": "Struct Trigger | Kobold Game Framework",
    "summary": "Struct Trigger Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as a non-solid trigger area. Used by systems to detect when other entities enter/exit specific regions without causing physical collision responses. Examples: CollisionSystem: Detects overlap but doesn't stop movement TriggerSystem: Activates events when entities enter trigger zones GameLogicSystem: Checkpoints, level transitions, cutscene triggers AudioSystem: Plays ambient sounds when player enters area Trigger entities typically also have: BoxCollider or other collision shape (defines the trigger area) TriggerAction component (what happens when triggered) TriggerFilter (which entity types can activate it) Common uses: Level exit portals Checkpoint save points Cutscene activation zones Environmental effect areas (damage zones, speed boosts) Audio cue regions public struct Trigger Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.UI.html": {
    "href": "api/Kobold.Core.Components.UI.html",
    "title": "Struct UI | Kobold Game Framework",
    "summary": "Struct UI Namespace Kobold.Core.Components Assembly Kobold.Core.dll Tag component marking an entity as a user interface element. Used by systems to handle UI-specific rendering, input, and layout behaviors. UI entities exist in screen space rather than world space. Examples: RenderSystem: Renders in screen coordinates with UI camera/layer InputSystem: Uses screen-space mouse coordinates for interaction LayoutSystem: Handles UI positioning, anchoring, scaling UISystem: Manages visibility based on game state UI entities typically also have: UITransform (screen position, anchoring) UIRenderer (text, images, buttons) UIInteractable (clickable, hoverable) Examples: buttons, text labels, health bars, menus, HUD elements These should generally be processed separately from world entities. public struct UI Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/Kobold.Core.Components.Velocity.html": {
    "href": "api/Kobold.Core.Components.Velocity.html",
    "title": "Struct Velocity | Kobold Game Framework",
    "summary": "Struct Velocity Namespace Kobold.Core.Components Assembly Kobold.Core.dll Component representing an entity's velocity (speed and direction) in 2D space. This is the rate of change of position - how fast and in what direction the entity is moving per second. Used by physics systems to update an entity's Transform.Position each frame. The basic movement equation is: newPosition = oldPosition + (velocity * deltaTime) Velocity is measured in pixels per second in the same coordinate system as Transform.Position. Positive X = moving right, Positive Y = moving down (standard screen coordinates). public struct Velocity Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Velocity(Vector2) Creates a new Velocity component with the specified velocity vector. public Velocity(Vector2 value) Parameters value Vector2 Velocity in pixels per second (X=horizontal, Y=vertical) Velocity(float, float) Creates a new Velocity component with the specified horizontal and vertical components. Convenience constructor for when you have separate X and Y velocities. public Velocity(float x, float y) Parameters x float Horizontal velocity in pixels per second (positive = right) y float Vertical velocity in pixels per second (positive = down) Fields Value The velocity vector in pixels per second. X component: Horizontal velocity (positive = moving right, negative = moving left) Y component: Vertical velocity (positive = moving down, negative = moving up) Magnitude of the vector represents speed: Vector2.Length() gives pixels/second Direction of the vector represents movement direction: Vector2.Normalize() gives unit direction Examples: (100, 0) = moving right at 100 pixels/second (0, -50) = moving up at 50 pixels/second (70.7, 70.7) = moving down-right at ~100 pixels/second (diagonal) (0, 0) = not moving (stationary) public Vector2 Value Field Value Vector2 Properties Direction Gets the direction of movement as a normalized vector (length = 1). Returns Vector2.Zero if the entity is not moving (velocity is zero). Useful for determining which way an entity is facing or for applying forces in the direction of movement. public readonly Vector2 Direction { get; } Property Value Vector2 IsMoving Gets whether this entity is currently moving (has non-zero velocity). Uses a small threshold to account for floating-point precision issues. public readonly bool IsMoving { get; } Property Value bool Speed Gets the speed (magnitude) of this velocity in pixels per second. This is always a positive value representing how fast the entity is moving, regardless of direction. public readonly float Speed { get; } Property Value float Zero Creates a stationary velocity (no movement). public static Velocity Zero { get; } Property Value Velocity Methods Add(Vector2) Adds the specified velocity to the current velocity. Useful for applying forces, impulses, or acceleration effects. public void Add(Vector2 deltaVelocity) Parameters deltaVelocity Vector2 Velocity change to apply ClampToMaxSpeed(float) Limits the velocity to the specified maximum speed. Maintains direction but caps the magnitude. Useful for implementing maximum movement speeds or terminal velocity. public void ClampToMaxSpeed(float maxSpeed) Parameters maxSpeed float Maximum speed in pixels per second FromAngleAndSpeed(float, float) Creates a velocity from an angle and speed. public static Velocity FromAngleAndSpeed(float angleRadians, float speed) Parameters angleRadians float Angle in radians (0 = right, π/2 = down) speed float Speed in pixels per second Returns Velocity Velocity component with the specified angle and speed FromDirectionAndSpeed(Vector2, float) Creates a velocity moving in the specified direction at the specified speed. public static Velocity FromDirectionAndSpeed(Vector2 direction, float speed) Parameters direction Vector2 Direction vector (will be normalized) speed float Speed in pixels per second Returns Velocity Velocity component with the specified direction and speed SetDirectionAndSpeed(Vector2, float) Sets the velocity to move in the specified direction at the specified speed. public void SetDirectionAndSpeed(Vector2 direction, float speed) Parameters direction Vector2 Direction to move (will be normalized automatically) speed float Speed in pixels per second ToString() Returns a human-readable string representation of this velocity. Useful for debugging and logging. public override readonly string ToString() Returns string"
  },
  "api/Kobold.Core.Components.html": {
    "href": "api/Kobold.Core.Components.html",
    "title": "Namespace Kobold.Core.Components | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Components Classes AnimationClip Defines a sequence of frames for an animation RenderLayers Standard rendering layer values Lower values render first (behind), higher values render last (on top) Structs Acceleration Acceleration component for entities that need forces applied over time AngularAcceleration Angular acceleration component AngularVelocity Angular velocity component for rotating entities Animation Component that manages sprite animation state BoxCollider Component defining a rectangular collision boundary for an entity. This creates an axis-aligned bounding box (AABB) used by collision detection systems to determine when entities are overlapping or touching. The collision box is positioned relative to the entity's Transform.Position, with an optional offset to fine-tune the collision area. The box doesn't rotate with the entity - it's always axis-aligned for performance. Camera Camera component that defines the viewport and follows a target. When present, the RenderSystem will automatically transform world coordinates to screen coordinates. CoreGameState Convenience wrapper for games that use the standard core game states. This provides a simpler API than the full generic GameState<TState> for common cases. Most simple games can just use this instead of defining their own state enum. Debug Tag component marking an entity as debug/development-only content. Used by systems to show diagnostic information, development tools, or testing content that should be hidden in production builds. Examples: RenderSystem: Only renders Debug entities in development builds InputSystem: Debug entities might respond to special key combinations LoggingSystem: Extra verbose logging for Debug entities ProfilerSystem: Performance monitoring for Debug entities Debug entities might include: Collision visualization (showing hitboxes) Performance counters and framerate displays AI pathfinding visualization Physics force indicators Entity inspector tools Cheat/testing controls Should be easily disabled for release builds via preprocessor directives or build configuration flags. Destructible Tag component marking an entity as destructible environment. Used by systems to handle breakable objects that can be damaged but aren't enemies (don't move, don't fight back). Examples: CollisionSystem: Takes damage from projectiles/explosions HealthSystem: Has hit points and can be destroyed EffectSystem: Shows damage effects, debris when destroyed ScoringSystem: May award points when destroyed Destructible entities typically also have: Health component (hit points) Collider (for damage detection) DropTable (what items spawn when destroyed) Examples: crates, barrels, walls, barriers, destructible terrain This is different from Static (can't be damaged) and Enemy (actively hostile). Drag Drag/friction component for air/space resistance Dynamic Tag component marking an entity as movable/physics-affected. Opposite of Static - indicates this entity should be processed by movement, physics, and dynamic collision systems. Examples: PhysicsSystem: Applies velocity, acceleration, and forces CollisionSystem: Full collision detection and response BoundarySystem: Handles boundary collisions (wrap, clamp, bounce) AISystem: Updates movement for dynamic AI entities Most game entities are Dynamic: Players, enemies, NPCs Projectiles, particles Moving platforms, elevators Physics objects like crates, balls Note: You don't usually need both Static and Dynamic tags in the same game. Choose one approach - either tag the minority case, or use presence/absence of Physics components. Enemy Tag component marking an entity as an enemy/hostile unit. Used by systems to identify entities that should attack the player, be targeted by player weapons, or follow enemy-specific behavior patterns. Examples: AISystem: Entities with Enemy tag use hostile AI behaviors CollisionSystem: Enemy vs Player projectile collision detection ScoringSystem: Award points when Enemy entities are destroyed FormationSystem: Enemy entities move in coordinated patterns SpawningSystem: Creates entities with Enemy tag during waves Often combined with other components like Health, Weapon, AIBehavior to create complete enemy entities with different capabilities. GameState<TState> Core game state component that represents the current high-level state of the game. This is used by the SystemManager to determine which systems should be active, and by game-specific systems to control flow and behavior. The core engine provides basic states (Playing, Paused, GameOver), but games can extend this with their own state enums by implementing IGameState. Only one GameState component should exist per game - it's typically attached to a singleton entity that represents the overall game session. Gravity Adds gravity to an entity MaxSpeed Maximum speed constraint for entities PendingDestruction Component to mark entities for destruction at the end of the frame This prevents mid-frame destruction issues with collision detection Physics Enhanced physics properties Player Tag component marking an entity as player-controlled. Used by systems to identify which entities should respond to player input, be affected by player-specific rules, or be treated specially by AI. Examples: InputSystem: Only moves entities with Player tag CameraSystem: Follows entities with Player tag CollisionSystem: Player vs Enemy collision rules UISystem: Updates health bars for Player entities In multiplayer games, you might have Player1, Player2 tags instead, or use a PlayerID component for more complex player management. PlayerControlled Component for entities controlled by player input PowerUp Tag component marking an entity as a collectible power-up or item. Used by systems to handle pickup mechanics, temporary effects, and inventory management. Examples: CollisionSystem: Player touching PowerUp triggers collection EffectSystem: Applies temporary bonuses when collected ScoringSystem: Awards points for collecting power-ups SpawningSystem: Creates PowerUp entities at specific locations/times RenderSystem: PowerUps might pulse, glow, or rotate for visibility PowerUp entities typically also have: PowerUpType component (what effect it provides) EffectDuration (how long the bonus lasts) CollectionValue (points awarded) Lifetime (despawn if not collected) Examples: health packs, weapon upgrades, speed boosts, shields, extra lives Projectile Tag component marking an entity as a projectile (bullet, missile, laser, etc.). Used by systems to apply projectile-specific behaviors like automatic movement, collision damage, and lifetime management. Examples: CollisionSystem: Projectiles damage targets and may be destroyed on impact BoundarySystem: Projectiles are usually destroyed when leaving screen bounds LifetimeSystem: Projectiles often have limited range/duration PhysicsSystem: Projectiles may ignore certain physics (like gravity) RenderSystem: Projectiles might use additive blending or special effects Projectile entities typically also have: Velocity (for movement) Lifetime (for range limiting) Damage (for collision effects) Owner (to prevent self-damage) Different projectile types can be distinguished using additional components or by having specific projectile tags (PlayerProjectile, EnemyProjectile). RectangleRenderer ScreenBounds SpriteRenderer Renders a sprite from a texture or sprite sheet Static Tag component marking an entity as non-moving/immovable. Used by physics and collision systems to optimize processing - static entities don't need velocity updates or complex collision resolution. Examples: PhysicsSystem: Skips velocity/acceleration updates for Static entities CollisionSystem: Uses simplified collision math (only other object moves) BoundarySystem: May skip boundary checking for Static entities RenderSystem: Can use different rendering optimizations for static sprites Common static entities: Walls, barriers, platforms Background decorations Fixed turrets or defensive structures UI elements positioned in world space TextRenderer Thruster Thruster component for entities that can apply thrust Transform Core component representing an entity's position, rotation, and scale in 2D world space. This is the fundamental spatial component that most other systems depend on - rendering, physics, collision detection, etc. all use Transform to determine where things are. Position is in world coordinates (pixels), rotation is in radians, and scale is a multiplier where Vector2.One (1,1) represents normal size. TriangleRenderer Triangle renderer component Trigger Tag component marking an entity as a non-solid trigger area. Used by systems to detect when other entities enter/exit specific regions without causing physical collision responses. Examples: CollisionSystem: Detects overlap but doesn't stop movement TriggerSystem: Activates events when entities enter trigger zones GameLogicSystem: Checkpoints, level transitions, cutscene triggers AudioSystem: Plays ambient sounds when player enters area Trigger entities typically also have: BoxCollider or other collision shape (defines the trigger area) TriggerAction component (what happens when triggered) TriggerFilter (which entity types can activate it) Common uses: Level exit portals Checkpoint save points Cutscene activation zones Environmental effect areas (damage zones, speed boosts) Audio cue regions UI Tag component marking an entity as a user interface element. Used by systems to handle UI-specific rendering, input, and layout behaviors. UI entities exist in screen space rather than world space. Examples: RenderSystem: Renders in screen coordinates with UI camera/layer InputSystem: Uses screen-space mouse coordinates for interaction LayoutSystem: Handles UI positioning, anchoring, scaling UISystem: Manages visibility based on game state UI entities typically also have: UITransform (screen position, anchoring) UIRenderer (text, images, buttons) UIInteractable (clickable, hoverable) Examples: buttons, text labels, health bars, menus, HUD elements These should generally be processed separately from world entities. Velocity Component representing an entity's velocity (speed and direction) in 2D space. This is the rate of change of position - how fast and in what direction the entity is moving per second. Used by physics systems to update an entity's Transform.Position each frame. The basic movement equation is: newPosition = oldPosition + (velocity * deltaTime) Velocity is measured in pixels per second in the same coordinate system as Transform.Position. Positive X = moving right, Positive Y = moving down (standard screen coordinates). Interfaces IRenderable Enums DestructionReason StandardGameState Standard game states that most games will need. Games can use this directly or create their own enum with these values included."
  },
  "api/Kobold.Core.Configuration.GameConfig.html": {
    "href": "api/Kobold.Core.Configuration.GameConfig.html",
    "title": "Class GameConfig | Kobold Game Framework",
    "summary": "Class GameConfig Namespace Kobold.Core.Configuration Assembly Kobold.Core.dll public class GameConfig Inheritance object GameConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GameConfig() public GameConfig() GameConfig(int, int, Color) public GameConfig(int screenWidth, int screenHeight, Color backgroundColor) Parameters screenWidth int screenHeight int backgroundColor Color Properties BackgroundColor public Color BackgroundColor { get; set; } Property Value Color ScreenHeight public int ScreenHeight { get; set; } Property Value int ScreenWidth public int ScreenWidth { get; set; } Property Value int"
  },
  "api/Kobold.Core.Configuration.html": {
    "href": "api/Kobold.Core.Configuration.html",
    "title": "Namespace Kobold.Core.Configuration | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Configuration Classes GameConfig"
  },
  "api/Kobold.Core.Events.BaseEvent.html": {
    "href": "api/Kobold.Core.Events.BaseEvent.html",
    "title": "Class BaseEvent | Kobold Game Framework",
    "summary": "Class BaseEvent Namespace Kobold.Core.Events Assembly Kobold.Core.dll public abstract class BaseEvent : IEvent Inheritance object BaseEvent Implements IEvent Derived GameRestartEvent GameStateChangedEvent<TGameState> BoundaryCollisionEvent CollisionEvent EntityDestroyedEvent TileDamageEvent TileTriggerEvent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Timestamp public DateTime Timestamp { get; } Property Value DateTime"
  },
  "api/Kobold.Core.Events.EventBus.html": {
    "href": "api/Kobold.Core.Events.EventBus.html",
    "title": "Class EventBus | Kobold Game Framework",
    "summary": "Class EventBus Namespace Kobold.Core.Events Assembly Kobold.Core.dll public class EventBus Inheritance object EventBus Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Clear() public void Clear() Publish<T>(T) public void Publish<T>(T eventData) where T : IEvent Parameters eventData T Type Parameters T Subscribe<T>(IEventHandler<T>) public void Subscribe<T>(IEventHandler<T> handler) where T : IEvent Parameters handler IEventHandler<T> Type Parameters T Subscribe<T>(Action<T>) public void Subscribe<T>(Action<T> handler) where T : IEvent Parameters handler Action<T> Type Parameters T Unsubscribe<T>(IEventHandler<T>) public void Unsubscribe<T>(IEventHandler<T> handler) where T : IEvent Parameters handler IEventHandler<T> Type Parameters T"
  },
  "api/Kobold.Core.Events.GameRestartEvent.html": {
    "href": "api/Kobold.Core.Events.GameRestartEvent.html",
    "title": "Class GameRestartEvent | Kobold Game Framework",
    "summary": "Class GameRestartEvent Namespace Kobold.Core.Events Assembly Kobold.Core.dll Event published when the game is restarted public class GameRestartEvent : BaseEvent, IEvent Inheritance object BaseEvent GameRestartEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Kobold.Core.Events.GameStateChangedEvent-1.html": {
    "href": "api/Kobold.Core.Events.GameStateChangedEvent-1.html",
    "title": "Class GameStateChangedEvent<TGameState> | Kobold Game Framework",
    "summary": "Class GameStateChangedEvent<TGameState> Namespace Kobold.Core.Events Assembly Kobold.Core.dll Event published when the game state changes public class GameStateChangedEvent<TGameState> : BaseEvent, IEvent where TGameState : struct Type Parameters TGameState Inheritance object BaseEvent GameStateChangedEvent<TGameState> Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GameStateChangedEvent(TGameState, TGameState) public GameStateChangedEvent(TGameState previousState, TGameState newState) Parameters previousState TGameState newState TGameState Properties NewState public TGameState NewState { get; } Property Value TGameState PreviousState public TGameState PreviousState { get; } Property Value TGameState"
  },
  "api/Kobold.Core.Events.IEvent.html": {
    "href": "api/Kobold.Core.Events.IEvent.html",
    "title": "Interface IEvent | Kobold Game Framework",
    "summary": "Interface IEvent Namespace Kobold.Core.Events Assembly Kobold.Core.dll public interface IEvent"
  },
  "api/Kobold.Core.Events.IEventHandler-1.html": {
    "href": "api/Kobold.Core.Events.IEventHandler-1.html",
    "title": "Interface IEventHandler<T> | Kobold Game Framework",
    "summary": "Interface IEventHandler<T> Namespace Kobold.Core.Events Assembly Kobold.Core.dll public interface IEventHandler<in T> where T : IEvent Type Parameters T Methods Handle(T) void Handle(T eventData) Parameters eventData T"
  },
  "api/Kobold.Core.Events.html": {
    "href": "api/Kobold.Core.Events.html",
    "title": "Namespace Kobold.Core.Events | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Events Classes BaseEvent EventBus GameRestartEvent Event published when the game is restarted GameStateChangedEvent<TGameState> Event published when the game state changes Interfaces IEvent IEventHandler<T>"
  },
  "api/Kobold.Core.Factories.EntityFactory.html": {
    "href": "api/Kobold.Core.Factories.EntityFactory.html",
    "title": "Class EntityFactory | Kobold Game Framework",
    "summary": "Class EntityFactory Namespace Kobold.Core.Factories Assembly Kobold.Core.dll Factory for creating common entites public class EntityFactory Inheritance object EntityFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EntityFactory(World) public EntityFactory(World world) Parameters world World Methods CreateMovingRectangle(Vector2, Vector2, Color, Vector2) public Entity CreateMovingRectangle(Vector2 position, Vector2 size, Color color, Vector2 velocity) Parameters position Vector2 size Vector2 color Color velocity Vector2 Returns Entity CreateRectangle(Vector2, Vector2, Color) public Entity CreateRectangle(Vector2 position, Vector2 size, Color color) Parameters position Vector2 size Vector2 color Color Returns Entity CreateText(Vector2, string, Color, float) public Entity CreateText(Vector2 position, string text, Color color, float fontSize = 16) Parameters position Vector2 text string color Color fontSize float Returns Entity"
  },
  "api/Kobold.Core.Factories.html": {
    "href": "api/Kobold.Core.Factories.html",
    "title": "Namespace Kobold.Core.Factories | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Factories Classes EntityFactory Factory for creating common entites"
  },
  "api/Kobold.Core.GameEngineBase.html": {
    "href": "api/Kobold.Core.GameEngineBase.html",
    "title": "Class GameEngineBase | Kobold Game Framework",
    "summary": "Class GameEngineBase Namespace Kobold.Core Assembly Kobold.Core.dll public abstract class GameEngineBase : IGameEngine Inheritance object GameEngineBase Implements IGameEngine Derived CellularAutomataDisplay Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GameEngineBase() public GameEngineBase() GameEngineBase(IRenderer, IInputManager) public GameEngineBase(IRenderer renderer, IInputManager inputManager) Parameters renderer IRenderer inputManager IInputManager Fields Assets protected AssetManager Assets Field Value AssetManager ContentLoader protected IContentLoader ContentLoader Field Value IContentLoader EventBus protected EventBus EventBus Field Value EventBus InputManager protected IInputManager InputManager Field Value IInputManager Renderer protected IRenderer Renderer Field Value IRenderer SystemManager protected SystemManager SystemManager Field Value SystemManager World protected World World Field Value World Methods Initialize() public virtual void Initialize() Render() public virtual void Render() SetContentLoader(IContentLoader) public void SetContentLoader(IContentLoader contentLoader) Parameters contentLoader IContentLoader SetInputManager(IInputManager) public void SetInputManager(IInputManager inputManager) Parameters inputManager IInputManager SetRenderer(IRenderer) public void SetRenderer(IRenderer renderer) Parameters renderer IRenderer Shutdown() public virtual void Shutdown() Update(float) public virtual void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.MathUtils.html": {
    "href": "api/Kobold.Core.MathUtils.html",
    "title": "Class MathUtils | Kobold Game Framework",
    "summary": "Class MathUtils Namespace Kobold.Core Assembly Kobold.Core.dll public static class MathUtils Inheritance object MathUtils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AngleDifference(float, float) Gets the shortest angle difference between two angles. public static float AngleDifference(float from, float to) Parameters from float From angle in radians to float To angle in radians Returns float Shortest angle difference in range [-PI, PI] Clamp(Vector2, Vector2, Vector2) public static Vector2 Clamp(Vector2 value, Vector2 min, Vector2 max) Parameters value Vector2 min Vector2 max Vector2 Returns Vector2 DegreesToRadians(float) Converts degrees to radians public static float DegreesToRadians(float degrees) Parameters degrees float Angle in degrees Returns float Angle in radians Lerp(Vector2, Vector2, float) Linearly interpolates between two Vector2 values public static Vector2 Lerp(Vector2 a, Vector2 b, float t) Parameters a Vector2 Start value b Vector2 End value t float Interpolation factor (0-1) Returns Vector2 Interpolated value Lerp(float, float, float) Linearly interpolates between two values public static float Lerp(float a, float b, float t) Parameters a float Start value b float End value t float Interpolation factor (0-1) Returns float Interpolated value MoveTowards(Vector2, Vector2, float) Moves a Vector2 towards a target by a maximum distance public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta) Parameters current Vector2 Current position target Vector2 Target position maxDistanceDelta float Maximum distance to move Returns Vector2 New position moved towards target MoveTowards(float, float, float) Moves a value towards a target by a maximum distance public static float MoveTowards(float current, float target, float maxDistanceDelta) Parameters current float Current value target float Target value maxDistanceDelta float Maximum distance to move Returns float New value moved towards target RadiansToDegrees(float) Converts radians to degrees public static float RadiansToDegrees(float radians) Parameters radians float Angle in radians Returns float Angle in degrees RandomDirection() public static Vector2 RandomDirection() Returns Vector2 RandomRange(float, float) public static float RandomRange(float min, float max) Parameters min float max float Returns float WrapAngle(float) Wraps an angle to be within -PI to PI range public static float WrapAngle(float angle) Parameters angle float Angle in radians Returns float Wrapped angle in range (-PI, PI]"
  },
  "api/Kobold.Core.Systems.AnimationSystem.html": {
    "href": "api/Kobold.Core.Systems.AnimationSystem.html",
    "title": "Class AnimationSystem | Kobold Game Framework",
    "summary": "Class AnimationSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll System that updates sprite animations public class AnimationSystem : ISystem Inheritance object AnimationSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AnimationSystem(World) public AnimationSystem(World world) Parameters world World Methods Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.BoundaryBehavior.html": {
    "href": "api/Kobold.Core.Systems.BoundaryBehavior.html",
    "title": "Enum BoundaryBehavior | Kobold Game Framework",
    "summary": "Enum BoundaryBehavior Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public enum BoundaryBehavior Fields Bounce = 2 Clamp = 0 Destroy = 3 Wrap = 1"
  },
  "api/Kobold.Core.Systems.BoundaryCollisionEvent.html": {
    "href": "api/Kobold.Core.Systems.BoundaryCollisionEvent.html",
    "title": "Class BoundaryCollisionEvent | Kobold Game Framework",
    "summary": "Class BoundaryCollisionEvent Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public class BoundaryCollisionEvent : BaseEvent, IEvent Inheritance object BaseEvent BoundaryCollisionEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BoundaryCollisionEvent(Entity, BoundaryType) public BoundaryCollisionEvent(Entity entity, BoundaryType boundary) Parameters entity Entity boundary BoundaryType Properties Boundary public BoundaryType Boundary { get; } Property Value BoundaryType Entity public Entity Entity { get; } Property Value Entity"
  },
  "api/Kobold.Core.Systems.BoundaryConfig.html": {
    "href": "api/Kobold.Core.Systems.BoundaryConfig.html",
    "title": "Class BoundaryConfig | Kobold Game Framework",
    "summary": "Class BoundaryConfig Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public class BoundaryConfig Inheritance object BoundaryConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BoundaryConfig() public BoundaryConfig() BoundaryConfig(float, float) public BoundaryConfig(float width, float height) Parameters width float height float Properties BoundaryBehavior public BoundaryBehavior BoundaryBehavior { get; set; } Property Value BoundaryBehavior DefaultBehavior public BoundaryBehavior DefaultBehavior { get; set; } Property Value BoundaryBehavior EnemyBehavior public BoundaryBehavior EnemyBehavior { get; set; } Property Value BoundaryBehavior Height public float Height { get; set; } Property Value float PlayerBehavior public BoundaryBehavior PlayerBehavior { get; set; } Property Value BoundaryBehavior ProjectileBehavior public BoundaryBehavior ProjectileBehavior { get; set; } Property Value BoundaryBehavior Width public float Width { get; set; } Property Value float"
  },
  "api/Kobold.Core.Systems.BoundarySystem.html": {
    "href": "api/Kobold.Core.Systems.BoundarySystem.html",
    "title": "Class BoundarySystem | Kobold Game Framework",
    "summary": "Class BoundarySystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Handles boundary collisions and wrapping public class BoundarySystem : ISystem Inheritance object BoundarySystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BoundarySystem(World, EventBus, BoundaryConfig) public BoundarySystem(World world, EventBus eventBus, BoundaryConfig config) Parameters world World eventBus EventBus config BoundaryConfig Methods Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.BoundaryType.html": {
    "href": "api/Kobold.Core.Systems.BoundaryType.html",
    "title": "Enum BoundaryType | Kobold Game Framework",
    "summary": "Enum BoundaryType Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public enum BoundaryType Fields Bottom = 1 Left = 2 Right = 3 Top = 0"
  },
  "api/Kobold.Core.Systems.CollisionConfig.html": {
    "href": "api/Kobold.Core.Systems.CollisionConfig.html",
    "title": "Class CollisionConfig | Kobold Game Framework",
    "summary": "Class CollisionConfig Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Configuration for collision detection and response public class CollisionConfig Inheritance object CollisionConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CollisionMatrix public CollisionMatrix CollisionMatrix { get; set; } Property Value CollisionMatrix EnableCollisionResponse public bool EnableCollisionResponse { get; set; } Property Value bool"
  },
  "api/Kobold.Core.Systems.CollisionEvent.html": {
    "href": "api/Kobold.Core.Systems.CollisionEvent.html",
    "title": "Class CollisionEvent | Kobold Game Framework",
    "summary": "Class CollisionEvent Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Enhanced collision event with detailed information public class CollisionEvent : BaseEvent, IEvent Inheritance object BaseEvent CollisionEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CollisionEvent(Entity, Entity) public CollisionEvent(Entity entity1, Entity entity2) Parameters entity1 Entity entity2 Entity CollisionEvent(Entity, Entity, Vector2, Vector2, CollisionLayer, CollisionLayer) public CollisionEvent(Entity entity1, Entity entity2, Vector2 collisionPoint, Vector2 collisionNormal, CollisionLayer layer1, CollisionLayer layer2) Parameters entity1 Entity entity2 Entity collisionPoint Vector2 collisionNormal Vector2 layer1 CollisionLayer layer2 CollisionLayer Properties CollisionNormal public Vector2 CollisionNormal { get; } Property Value Vector2 CollisionPoint public Vector2 CollisionPoint { get; } Property Value Vector2 Entity1 public Entity Entity1 { get; } Property Value Entity Entity2 public Entity Entity2 { get; } Property Value Entity Layer1 public CollisionLayer Layer1 { get; } Property Value CollisionLayer Layer2 public CollisionLayer Layer2 { get; } Property Value CollisionLayer"
  },
  "api/Kobold.Core.Systems.CollisionLayer.html": {
    "href": "api/Kobold.Core.Systems.CollisionLayer.html",
    "title": "Enum CollisionLayer | Kobold Game Framework",
    "summary": "Enum CollisionLayer Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Collision layers for filtering public enum CollisionLayer Fields Default = 0 Enemy = 2 EnemyProjectile = 6 Environment = 4 Pickup = 7 Player = 1 PlayerProjectile = 5 Projectile = 3 Trigger = 8"
  },
  "api/Kobold.Core.Systems.CollisionLayerComponent.html": {
    "href": "api/Kobold.Core.Systems.CollisionLayerComponent.html",
    "title": "Struct CollisionLayerComponent | Kobold Game Framework",
    "summary": "Struct CollisionLayerComponent Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Component to assign collision layers to entities public struct CollisionLayerComponent Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollisionLayerComponent(CollisionLayer) public CollisionLayerComponent(CollisionLayer layer) Parameters layer CollisionLayer Fields Layer public CollisionLayer Layer Field Value CollisionLayer"
  },
  "api/Kobold.Core.Systems.CollisionMatrix.html": {
    "href": "api/Kobold.Core.Systems.CollisionMatrix.html",
    "title": "Class CollisionMatrix | Kobold Game Framework",
    "summary": "Class CollisionMatrix Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Matrix defining which layers can collide with each other public class CollisionMatrix Inheritance object CollisionMatrix Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CollisionMatrix() public CollisionMatrix() Methods CanCollide(CollisionLayer, CollisionLayer) public bool CanCollide(CollisionLayer layer1, CollisionLayer layer2) Parameters layer1 CollisionLayer layer2 CollisionLayer Returns bool SetCollision(CollisionLayer, CollisionLayer, bool) public void SetCollision(CollisionLayer layer1, CollisionLayer layer2, bool canCollide) Parameters layer1 CollisionLayer layer2 CollisionLayer canCollide bool"
  },
  "api/Kobold.Core.Systems.CollisionSystem.html": {
    "href": "api/Kobold.Core.Systems.CollisionSystem.html",
    "title": "Class CollisionSystem | Kobold Game Framework",
    "summary": "Class CollisionSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Enhanced collision system with filtering, layers, and circle collision support public class CollisionSystem : ISystem Inheritance object CollisionSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CollisionSystem(World, EventBus, CollisionConfig) public CollisionSystem(World world, EventBus eventBus, CollisionConfig config = null) Parameters world World eventBus EventBus config CollisionConfig Methods AreEntitiesColliding(Entity, Entity) Check if two specific entities are colliding public bool AreEntitiesColliding(Entity entity1, Entity entity2) Parameters entity1 Entity entity2 Entity Returns bool Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.DestructionStats.html": {
    "href": "api/Kobold.Core.Systems.DestructionStats.html",
    "title": "Struct DestructionStats | Kobold Game Framework",
    "summary": "Struct DestructionStats Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Debug information about the destruction system public struct DestructionStats Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields EntitiesDestroyedThisFrame public int EntitiesDestroyedThisFrame Field Value int EntitiesPendingDestruction public int EntitiesPendingDestruction Field Value int EntitiesWithLifetime public int EntitiesWithLifetime Field Value int Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/Kobold.Core.Systems.DestructionSystem.html": {
    "href": "api/Kobold.Core.Systems.DestructionSystem.html",
    "title": "Class DestructionSystem | Kobold Game Framework",
    "summary": "Class DestructionSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Unified system that handles both lifetime expiration and pending destruction Processes all entity destruction at the end of the frame for safety public class DestructionSystem : ISystem Inheritance object DestructionSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DestructionSystem(World, EventBus) public DestructionSystem(World world, EventBus eventBus = null) Parameters world World eventBus EventBus Methods GetStats() Get destruction statistics for debugging public DestructionStats GetStats() Returns DestructionStats MarkForDestruction(World, Entity, DestructionReason, float) Mark an entity for destruction (safer than immediate destruction) public static void MarkForDestruction(World world, Entity entity, DestructionReason reason = DestructionReason.Manual, float delay = 0) Parameters world World entity Entity reason DestructionReason delay float SetLifetime(World, Entity, float) Create an entity with a lifetime (convenience method) public static void SetLifetime(World world, Entity entity, float lifetime) Parameters world World entity Entity lifetime float Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.EntityDestroyedEvent.html": {
    "href": "api/Kobold.Core.Systems.EntityDestroyedEvent.html",
    "title": "Class EntityDestroyedEvent | Kobold Game Framework",
    "summary": "Class EntityDestroyedEvent Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Enhanced destruction event with position information public class EntityDestroyedEvent : BaseEvent, IEvent Inheritance object BaseEvent EntityDestroyedEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EntityDestroyedEvent(Entity, DestructionReason, Vector2) public EntityDestroyedEvent(Entity entity, DestructionReason reason, Vector2 position = default) Parameters entity Entity reason DestructionReason position Vector2 Properties Entity public Entity Entity { get; } Property Value Entity Position public Vector2 Position { get; } Property Value Vector2 Reason public DestructionReason Reason { get; } Property Value DestructionReason"
  },
  "api/Kobold.Core.Systems.GameStateSystem-1.html": {
    "href": "api/Kobold.Core.Systems.GameStateSystem-1.html",
    "title": "Class GameStateSystem<TGameState> | Kobold Game Framework",
    "summary": "Class GameStateSystem<TGameState> Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Generic game state management system. Configure states with callbacks and an input that should trigger a transition out of this state if applicable. Then calling ChangeState will handle performing the callbacks and publishing a GameStateChangedEvent. public class GameStateSystem<TGameState> : ISystem where TGameState : struct Type Parameters TGameState Inheritance object GameStateSystem<TGameState> Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GameStateSystem(World, EventBus, IInputManager) public GameStateSystem(World world, EventBus eventBus, IInputManager inputManager) Parameters world World eventBus EventBus inputManager IInputManager Fields EventBus protected readonly EventBus EventBus Field Value EventBus InputManager protected readonly IInputManager InputManager Field Value IInputManager World protected readonly World World Field Value World Methods ChangeState(TGameState) public void ChangeState(TGameState newState) Parameters newState TGameState ConfigureState(TGameState, StateConfig) public void ConfigureState(TGameState state, StateConfig config) Parameters state TGameState config StateConfig GetCurrentState() public TGameState GetCurrentState() Returns TGameState HandleStateChange(TGameState, TGameState) protected virtual void HandleStateChange(TGameState newState, TGameState previousState) Parameters newState TGameState previousState TGameState HandleStateTransitionInputs() protected virtual void HandleStateTransitionInputs() Update(float) public virtual void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.InputSystem.html": {
    "href": "api/Kobold.Core.Systems.InputSystem.html",
    "title": "Class InputSystem | Kobold Game Framework",
    "summary": "Class InputSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Generic input system that handles PlayerControlled entities Can be used directly or extended for custom input handling public class InputSystem : ISystem Inheritance object InputSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputSystem(IInputManager, World) public InputSystem(IInputManager inputManager, World world) Parameters inputManager IInputManager world World Fields InputManager protected readonly IInputManager InputManager Field Value IInputManager World protected readonly World World Field Value World Methods HandleMovement<T>(float, KeyCode, KeyCode, KeyCode, KeyCode, bool) Generic movement handler for any component type with custom key bindings protected void HandleMovement<T>(float speed, KeyCode up, KeyCode down, KeyCode left = KeyCode.Left, KeyCode right = KeyCode.Right, bool verticalOnly = false) where T : struct Parameters speed float up KeyCode down KeyCode left KeyCode right KeyCode verticalOnly bool Type Parameters T HandlePlayerControlledMovement() Handles movement for entities with PlayerControlled component protected void HandlePlayerControlledMovement() IsAnyDirectionalKeyPressed() Checks if any directional key is pressed protected bool IsAnyDirectionalKeyPressed() Returns bool Update(float) public virtual void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.InputTransition.html": {
    "href": "api/Kobold.Core.Systems.InputTransition.html",
    "title": "Class InputTransition | Kobold Game Framework",
    "summary": "Class InputTransition Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public class InputTransition Inheritance object InputTransition Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Key public KeyCode Key { get; set; } Property Value KeyCode NextState public object NextState { get; set; } Property Value object OnTransition public Action OnTransition { get; set; } Property Value Action"
  },
  "api/Kobold.Core.Systems.PhysicsConfig.html": {
    "href": "api/Kobold.Core.Systems.PhysicsConfig.html",
    "title": "Class PhysicsConfig | Kobold Game Framework",
    "summary": "Class PhysicsConfig Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Configuration for physics simulation public class PhysicsConfig Inheritance object PhysicsConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DefaultAngularDamping public float DefaultAngularDamping { get; set; } Property Value float DefaultDamping public float DefaultDamping { get; set; } Property Value float DefaultLinearDamping public float DefaultLinearDamping { get; set; } Property Value float EnableDamping public bool EnableDamping { get; set; } Property Value bool EnableGravity public bool EnableGravity { get; set; } Property Value bool EnableRotationalPhysics public bool EnableRotationalPhysics { get; set; } Property Value bool EnableSpeedLimits public bool EnableSpeedLimits { get; set; } Property Value bool EnableThrust public bool EnableThrust { get; set; } Property Value bool GlobalGravity public Vector2 GlobalGravity { get; set; } Property Value Vector2 MinVelocityThreshold public float MinVelocityThreshold { get; set; } Property Value float UseMultiplicativeDamping public bool UseMultiplicativeDamping { get; set; } Property Value bool"
  },
  "api/Kobold.Core.Systems.PhysicsSystem.html": {
    "href": "api/Kobold.Core.Systems.PhysicsSystem.html",
    "title": "Class PhysicsSystem | Kobold Game Framework",
    "summary": "Class PhysicsSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Handles basic physics simulation including position, velocity, and acceleration public class PhysicsSystem : ISystem Inheritance object PhysicsSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PhysicsSystem(World, PhysicsConfig) public PhysicsSystem(World world, PhysicsConfig config = null) Parameters world World config PhysicsConfig Methods Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.RenderSystem.html": {
    "href": "api/Kobold.Core.Systems.RenderSystem.html",
    "title": "Class RenderSystem | Kobold Game Framework",
    "summary": "Class RenderSystem Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public class RenderSystem : IRenderSystem Inheritance object RenderSystem Implements IRenderSystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RenderSystem(IRenderer, World) public RenderSystem(IRenderer renderer, World world) Parameters renderer IRenderer world World Methods Render() public void Render()"
  },
  "api/Kobold.Core.Systems.StateConfig.html": {
    "href": "api/Kobold.Core.Systems.StateConfig.html",
    "title": "Class StateConfig | Kobold Game Framework",
    "summary": "Class StateConfig Namespace Kobold.Core.Systems Assembly Kobold.Core.dll public class StateConfig Inheritance object StateConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InputTransitions public List<InputTransition> InputTransitions { get; set; } Property Value List<InputTransition> OnStateEnter public Action OnStateEnter { get; set; } Property Value Action OnStateExit public Action OnStateExit { get; set; } Property Value Action"
  },
  "api/Kobold.Core.Systems.SystemInfo.html": {
    "href": "api/Kobold.Core.Systems.SystemInfo.html",
    "title": "Class SystemInfo | Kobold Game Framework",
    "summary": "Class SystemInfo Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Information about a system for management public class SystemInfo Inheritance object SystemInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SystemInfo(ISystem, int, bool) public SystemInfo(ISystem system, int order, bool requiresGameplayState) Parameters system ISystem order int requiresGameplayState bool Properties IsEnabled public bool IsEnabled { get; set; } Property Value bool Order public int Order { get; } Property Value int RequiresGameplayState public bool RequiresGameplayState { get; } Property Value bool System public ISystem System { get; } Property Value ISystem"
  },
  "api/Kobold.Core.Systems.SystemManager.html": {
    "href": "api/Kobold.Core.Systems.SystemManager.html",
    "title": "Class SystemManager | Kobold Game Framework",
    "summary": "Class SystemManager Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Enhanced system manager with ordering and render system support public class SystemManager Inheritance object SystemManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SystemManager(EventBus, World) public SystemManager(EventBus eventBus, World world) Parameters eventBus EventBus world World Methods AddHybridSystem(ISystem, int, bool) Add a system that implements both ISystem and IRenderSystem public void AddHybridSystem(ISystem system, int order = 400, bool requiresGameplayState = true) Parameters system ISystem order int requiresGameplayState bool AddRenderSystem(IRenderSystem) Add a render system (these are always active) public void AddRenderSystem(IRenderSystem renderSystem) Parameters renderSystem IRenderSystem AddSystem(ISystem, int, bool) Add a regular update system public void AddSystem(ISystem system, int order = 400, bool requiresGameplayState = true) Parameters system ISystem order int requiresGameplayState bool ClearSystems() Clear all systems public void ClearSystems() GetSystemInfo() Get system information for debugging public SystemManagerInfo GetSystemInfo() Returns SystemManagerInfo GetSystem<T>() Get a specific system by type public T GetSystem<T>() where T : class Returns T Type Parameters T GetSystems<T>() Get all systems of a specific type public IEnumerable<T> GetSystems<T>() where T : class Returns IEnumerable<T> Type Parameters T IsSystemEnabled(ISystem) Check if a system is enabled public bool IsSystemEnabled(ISystem system) Parameters system ISystem Returns bool RemoveRenderSystem(IRenderSystem) Remove a render system public void RemoveRenderSystem(IRenderSystem renderSystem) Parameters renderSystem IRenderSystem RemoveSystem(ISystem) Remove a system public void RemoveSystem(ISystem system) Parameters system ISystem RenderAll() Render all render systems public void RenderAll() SetSystemEnabled(ISystem, bool) Enable or disable a system public void SetSystemEnabled(ISystem system, bool enabled) Parameters system ISystem enabled bool UpdateAll(float) Update all systems in order public void UpdateAll(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Core.Systems.SystemManagerInfo.html": {
    "href": "api/Kobold.Core.Systems.SystemManagerInfo.html",
    "title": "Class SystemManagerInfo | Kobold Game Framework",
    "summary": "Class SystemManagerInfo Namespace Kobold.Core.Systems Assembly Kobold.Core.dll Debug information about the system manager public class SystemManagerInfo Inheritance object SystemManagerInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties AlwaysUpdateSystems public int AlwaysUpdateSystems { get; set; } Property Value int GameplaySystems public int GameplaySystems { get; set; } Property Value int IsGamePlaying public bool IsGamePlaying { get; set; } Property Value bool RenderSystems public int RenderSystems { get; set; } Property Value int TotalSystems public int TotalSystems { get; set; } Property Value int Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/Kobold.Core.Systems.SystemUpdateOrder.html": {
    "href": "api/Kobold.Core.Systems.SystemUpdateOrder.html",
    "title": "Class SystemUpdateOrder | Kobold Game Framework",
    "summary": "Class SystemUpdateOrder Namespace Kobold.Core.Systems Assembly Kobold.Core.dll System execution order constants public static class SystemUpdateOrder Inheritance object SystemUpdateOrder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields AI public const int AI = 200 Field Value int CLEANUP public const int CLEANUP = 600 Field Value int COLLISION public const int COLLISION = 300 Field Value int GAME_LOGIC public const int GAME_LOGIC = 400 Field Value int INPUT public const int INPUT = 0 Field Value int PHYSICS public const int PHYSICS = 100 Field Value int UI public const int UI = 500 Field Value int"
  },
  "api/Kobold.Core.Systems.html": {
    "href": "api/Kobold.Core.Systems.html",
    "title": "Namespace Kobold.Core.Systems | Kobold Game Framework",
    "summary": "Namespace Kobold.Core.Systems Classes AnimationSystem System that updates sprite animations BoundaryCollisionEvent BoundaryConfig BoundarySystem Handles boundary collisions and wrapping CollisionConfig Configuration for collision detection and response CollisionEvent Enhanced collision event with detailed information CollisionMatrix Matrix defining which layers can collide with each other CollisionSystem Enhanced collision system with filtering, layers, and circle collision support DestructionSystem Unified system that handles both lifetime expiration and pending destruction Processes all entity destruction at the end of the frame for safety EntityDestroyedEvent Enhanced destruction event with position information GameStateSystem<TGameState> Generic game state management system. Configure states with callbacks and an input that should trigger a transition out of this state if applicable. Then calling ChangeState will handle performing the callbacks and publishing a GameStateChangedEvent. InputSystem Generic input system that handles PlayerControlled entities Can be used directly or extended for custom input handling InputTransition PhysicsConfig Configuration for physics simulation PhysicsSystem Handles basic physics simulation including position, velocity, and acceleration RenderSystem StateConfig SystemInfo Information about a system for management SystemManager Enhanced system manager with ordering and render system support SystemManagerInfo Debug information about the system manager SystemUpdateOrder System execution order constants Structs CollisionLayerComponent Component to assign collision layers to entities DestructionStats Debug information about the destruction system Enums BoundaryBehavior BoundaryType CollisionLayer Collision layers for filtering"
  },
  "api/Kobold.Core.html": {
    "href": "api/Kobold.Core.html",
    "title": "Namespace Kobold.Core | Kobold Game Framework",
    "summary": "Namespace Kobold.Core Classes AssetManager Manages loading and caching of game assets (textures, sprite sheets, etc.) GameEngineBase MathUtils"
  },
  "api/Kobold.Extensions.Procedural.CellularAutomataConfig.html": {
    "href": "api/Kobold.Extensions.Procedural.CellularAutomataConfig.html",
    "title": "Class CellularAutomataConfig | Kobold Game Framework",
    "summary": "Class CellularAutomataConfig Namespace Kobold.Extensions.Procedural Assembly Kobold.Extensions.dll Configuration options for cellular automata generation. public class CellularAutomataConfig Inheritance object CellularAutomataConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BirthThreshold Minimum number of neighboring walls for a cell to become/remain a wall. Used during smoothing iterations. public int BirthThreshold { get; set; } Property Value int ConnectCaves Whether to connect all cave regions with corridors. When true, uses flood fill + MST to ensure all caves are reachable. public bool ConnectCaves { get; set; } Property Value bool DeathThreshold Maximum number of neighboring walls for a cell to remain alive. If neighbors exceed this, the cell dies (becomes floor). public int DeathThreshold { get; set; } Property Value int EdgeIsWall Whether to treat edges of the map as walls. When true, out-of-bounds cells count as walls for neighbor calculations. public bool EdgeIsWall { get; set; } Property Value bool FloorTileId Tile ID to use for floor/empty tiles. public int FloorTileId { get; set; } Property Value int Height Height of the map in tiles. public int Height { get; set; } Property Value int InitialWallProbability Initial chance (0.0 to 1.0) that a cell is a wall. Higher values create more walls/obstacles. public float InitialWallProbability { get; set; } Property Value float Iterations Number of smoothing iterations to perform. Higher values create smoother, more organic shapes. public int Iterations { get; set; } Property Value int MinCaveSize Minimum size (in tiles) for a cave region to be kept. Smaller regions are filled in as walls. public int MinCaveSize { get; set; } Property Value int Seed Random seed for deterministic generation. If null, a random seed is used. public int? Seed { get; set; } Property Value int? TileHeight Height of each tile in pixels (for TileMap creation). public int TileHeight { get; set; } Property Value int TileWidth Width of each tile in pixels (for TileMap creation). public int TileWidth { get; set; } Property Value int WallTileId Tile ID to use for wall tiles. public int WallTileId { get; set; } Property Value int Width Width of the map in tiles. public int Width { get; set; } Property Value int Methods Cave() Creates a default configuration for cave-like generation. public static CellularAutomataConfig Cave() Returns CellularAutomataConfig Maze() Creates a configuration for dense maze-like structures. public static CellularAutomataConfig Maze() Returns CellularAutomataConfig OpenArea() Creates a configuration for more open areas with scattered obstacles. public static CellularAutomataConfig OpenArea() Returns CellularAutomataConfig"
  },
  "api/Kobold.Extensions.Procedural.CellularAutomataGenerator.html": {
    "href": "api/Kobold.Extensions.Procedural.CellularAutomataGenerator.html",
    "title": "Class CellularAutomataGenerator | Kobold Game Framework",
    "summary": "Class CellularAutomataGenerator Namespace Kobold.Extensions.Procedural Assembly Kobold.Extensions.dll Generates tilemaps using cellular automata algorithms. Useful for creating organic cave-like structures and procedural dungeons. public class CellularAutomataGenerator Inheritance object CellularAutomataGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CellularAutomataGenerator(CellularAutomataConfig) public CellularAutomataGenerator(CellularAutomataConfig config) Parameters config CellularAutomataConfig Methods Generate() Generates a new tilemap using cellular automata. public TileMap Generate() Returns TileMap Generated TileMap GenerateWithTileSet(bool) Generates a tilemap and tileset together. The tileset will have wall and floor tiles configured with appropriate properties. public (TileMap tileMap, TileSet tileSet) GenerateWithTileSet(bool wallIsSolid = true) Parameters wallIsSolid bool Whether wall tiles should have collision Returns (TileMap tileMap, TileSet tileSet) Tuple of (TileMap, TileSet) GetGrid() Gets the current state of the grid (for debugging or visualization). public bool[,] GetGrid() Returns bool[,] Copy of the current grid state"
  },
  "api/Kobold.Extensions.Procedural.html": {
    "href": "api/Kobold.Extensions.Procedural.html",
    "title": "Namespace Kobold.Extensions.Procedural | Kobold Game Framework",
    "summary": "Namespace Kobold.Extensions.Procedural Classes CellularAutomataConfig Configuration options for cellular automata generation. CellularAutomataGenerator Generates tilemaps using cellular automata algorithms. Useful for creating organic cave-like structures and procedural dungeons."
  },
  "api/Kobold.Extensions.Tilemaps.TileCollisionLayer.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileCollisionLayer.html",
    "title": "Enum TileCollisionLayer | Kobold Game Framework",
    "summary": "Enum TileCollisionLayer Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Collision layers for tiles. public enum TileCollisionLayer Fields Ice = 5 Ice (reduced friction) Ladder = 6 Ladder (climbable) None = 0 No collision Platform = 2 Platform (one-way collision from above) Solid = 1 Solid tile (blocks from all directions) Trigger = 3 Trigger/sensor (detects but doesn't block) Water = 4 Water (special movement behavior)"
  },
  "api/Kobold.Extensions.Tilemaps.TileDamageEvent.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileDamageEvent.html",
    "title": "Class TileDamageEvent | Kobold Game Framework",
    "summary": "Class TileDamageEvent Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Event published when an entity takes damage from a tile. public class TileDamageEvent : BaseEvent, IEvent Inheritance object BaseEvent TileDamageEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TileDamageEvent(Entity, int, string) public TileDamageEvent(Entity entity, int damage, string damageType) Parameters entity Entity damage int damageType string Properties Damage public int Damage { get; } Property Value int DamageType public string DamageType { get; } Property Value string Entity public Entity Entity { get; } Property Value Entity"
  },
  "api/Kobold.Extensions.Tilemaps.TileMap.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileMap.html",
    "title": "Class TileMap | Kobold Game Framework",
    "summary": "Class TileMap Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Represents a grid-based tilemap with support for multiple layers. public class TileMap Inheritance object TileMap Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TileMap(int, int, int, int, int) Creates a new tilemap with the specified dimensions. public TileMap(int width, int height, int tileWidth, int tileHeight, int layerCount = 1) Parameters width int Width in tiles height int Height in tiles tileWidth int Width of each tile in pixels tileHeight int Height of each tile in pixels layerCount int Number of layers (default: 1) Properties Height public int Height { get; } Property Value int LayerCount public int LayerCount { get; } Property Value int TileHeight public int TileHeight { get; } Property Value int TileWidth public int TileWidth { get; } Property Value int Width public int Width { get; } Property Value int Methods Clear() Clears all tiles on all layers. public void Clear() ClearLayer(int) Clears all tiles on the specified layer (sets them to -1). public void ClearLayer(int layer) Parameters layer int Layer index to clear Clone() Creates a copy of this tilemap. public TileMap Clone() Returns TileMap Fill(int, int, int, int, int, int) Fills a rectangular region with the specified tile ID. public void Fill(int layer, int x, int y, int width, int height, int tileId) Parameters layer int Layer index (0-based) x int Starting X coordinate y int Starting Y coordinate width int Width in tiles height int Height in tiles tileId int Tile ID to fill with GetPixelSize() Gets the total size of the tilemap in pixels. public (int pixelWidth, int pixelHeight) GetPixelSize() Returns (int tileX, int tileY) GetTile(int, int, int) Gets the tile ID at the specified position and layer. public int GetTile(int layer, int x, int y) Parameters layer int Layer index (0-based) x int X coordinate in tile units y int Y coordinate in tile units Returns int Tile ID, or -1 if empty or out of bounds GetTilesInBounds(int, int, int, int, int) Gets all tiles within the specified rectangular bounds. public List<(int x, int y, int tileId)> GetTilesInBounds(int layer, int x, int y, int width, int height) Parameters layer int Layer index x int Starting X coordinate y int Starting Y coordinate width int Width in tiles height int Height in tiles Returns List<(int x, int y, int tileId)> List of tile positions and IDs IsValidLayer(int) Checks if the specified layer index is valid. public bool IsValidLayer(int layer) Parameters layer int Returns bool IsValidPosition(int, int) Checks if the specified tile coordinates are within bounds. public bool IsValidPosition(int x, int y) Parameters x int y int Returns bool SetTile(int, int, int, int) Sets the tile ID at the specified position and layer. public void SetTile(int layer, int x, int y, int tileId) Parameters layer int Layer index (0-based) x int X coordinate in tile units y int Y coordinate in tile units tileId int Tile ID to set (-1 for empty) TileToWorld(int, int) Converts tile coordinates to world position (in pixels, top-left corner of tile). public (float worldX, float worldY) TileToWorld(int tileX, int tileY) Parameters tileX int X coordinate in tiles tileY int Y coordinate in tiles Returns (float worldX, float worldY) World position in pixels TileToWorldCenter(int, int) Gets the center position of a tile in world coordinates. public (float worldX, float worldY) TileToWorldCenter(int tileX, int tileY) Parameters tileX int tileY int Returns (float worldX, float worldY) WorldToTile(float, float) Converts world position (in pixels) to tile coordinates. public (int tileX, int tileY) WorldToTile(float worldX, float worldY) Parameters worldX float X position in pixels worldY float Y position in pixels Returns (int tileX, int tileY) Tile coordinates"
  },
  "api/Kobold.Extensions.Tilemaps.TileProperties.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileProperties.html",
    "title": "Struct TileProperties | Kobold Game Framework",
    "summary": "Struct TileProperties Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Properties associated with a tile. public struct TileProperties Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors TileProperties() Creates default tile properties (non-solid, no special behavior). public TileProperties() Properties AnimationFrames Animation frame IDs if this tile is animated. public int[]? AnimationFrames { readonly get; set; } Property Value int[] AnimationSpeed Animation speed in frames per second. public float AnimationSpeed { readonly get; set; } Property Value float CollisionLayer Collision layer for this tile. public TileCollisionLayer CollisionLayer { readonly get; set; } Property Value TileCollisionLayer CustomProperties Custom properties for game-specific data. public Dictionary<string, object>? CustomProperties { readonly get; set; } Property Value Dictionary<string, object> Damage Damage dealt to entities that touch this tile. public int Damage { readonly get; set; } Property Value int Friction Friction coefficient (0 = no friction, 1 = full friction). public float Friction { readonly get; set; } Property Value float IsAnimated Whether this tile is animated. public bool IsAnimated { readonly get; set; } Property Value bool IsSolid Whether this tile blocks movement (collision). public bool IsSolid { readonly get; set; } Property Value bool Type Type identifier for special tile behaviors (e.g., \"water\", \"lava\", \"ice\"). public string? Type { readonly get; set; } Property Value string Methods Platform() Creates a platform tile (one-way collision from above). public static TileProperties Platform() Returns TileProperties Solid() Creates a solid tile with default properties. public static TileProperties Solid() Returns TileProperties WithDamage(int, string) Creates a damage tile. public static TileProperties WithDamage(int damage, string type = \"damage\") Parameters damage int type string Returns TileProperties"
  },
  "api/Kobold.Extensions.Tilemaps.TileSet.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileSet.html",
    "title": "Class TileSet | Kobold Game Framework",
    "summary": "Class TileSet Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Represents a collection of tiles with their properties. Maps tile IDs to their visual and gameplay properties. public class TileSet Inheritance object TileSet Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TileSet(int, int, int, int) Creates a new tileset. public TileSet(int tileWidth, int tileHeight, int spacing = 0, int margin = 0) Parameters tileWidth int Width of each tile in pixels tileHeight int Height of each tile in pixels spacing int Spacing between tiles in the tileset image (default: 0) margin int Margin around the tileset image (default: 0) Properties Margin public int Margin { get; } Property Value int Spacing public int Spacing { get; } Property Value int TexturePath Optional texture/sprite sheet name or path for rendering. The actual texture loading is handled by the platform-specific renderer. public string? TexturePath { get; set; } Property Value string TileCount public int TileCount { get; } Property Value int TileHeight public int TileHeight { get; } Property Value int TileWidth public int TileWidth { get; } Property Value int Methods FromTexture(string, int, int, int, int, int, int) Creates a tileset from a texture with automatic tile calculation. public static TileSet FromTexture(string texturePath, int textureWidth, int textureHeight, int tileWidth, int tileHeight, int spacing = 0, int margin = 0) Parameters texturePath string Path to the tileset texture textureWidth int Width of the texture in pixels textureHeight int Height of the texture in pixels tileWidth int Width of each tile tileHeight int Height of each tile spacing int Spacing between tiles margin int Margin around the tileset Returns TileSet New tileset GetCollisionLayer(int) Gets the collision layer for a tile. public TileCollisionLayer GetCollisionLayer(int tileId) Parameters tileId int Returns TileCollisionLayer GetTileProperties(int) Gets properties for a specific tile ID. Returns default properties if the tile ID hasn't been configured. public TileProperties GetTileProperties(int tileId) Parameters tileId int Tile ID Returns TileProperties Tile properties GetTileSourceRect(int, int) Calculates the source rectangle for a tile in a tileset image. Useful for sprite sheet rendering. public (int x, int y, int width, int height) GetTileSourceRect(int tileId, int tilesPerRow) Parameters tileId int Tile ID tilesPerRow int Number of tiles per row in the tileset image Returns (int x, int y, int width, int height) Source rectangle (x, y, width, height) IsSolid(int) Checks if a tile is solid (blocks movement). public bool IsSolid(int tileId) Parameters tileId int Returns bool SetTileProperties(int, TileProperties) Sets properties for a specific tile ID. public void SetTileProperties(int tileId, TileProperties properties) Parameters tileId int Tile ID properties TileProperties Tile properties SetTileRange(int, int, TileProperties) Configures multiple tiles with the same properties. public void SetTileRange(int startTileId, int count, TileProperties properties) Parameters startTileId int Starting tile ID count int Number of tiles to configure properties TileProperties Properties to apply"
  },
  "api/Kobold.Extensions.Tilemaps.TileTriggerEvent.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TileTriggerEvent.html",
    "title": "Class TileTriggerEvent | Kobold Game Framework",
    "summary": "Class TileTriggerEvent Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Event published when an entity triggers a tile. public class TileTriggerEvent : BaseEvent, IEvent Inheritance object BaseEvent TileTriggerEvent Implements IEvent Inherited Members BaseEvent.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TileTriggerEvent(Entity, int, int, string) public TileTriggerEvent(Entity entity, int tileX, int tileY, string triggerType) Parameters entity Entity tileX int tileY int triggerType string Properties Entity public Entity Entity { get; } Property Value Entity TileX public int TileX { get; } Property Value int TileY public int TileY { get; } Property Value int TriggerType public string TriggerType { get; } Property Value string"
  },
  "api/Kobold.Extensions.Tilemaps.TilemapCollisionConfig.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TilemapCollisionConfig.html",
    "title": "Class TilemapCollisionConfig | Kobold Game Framework",
    "summary": "Class TilemapCollisionConfig Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll Configuration for tilemap collision system. public class TilemapCollisionConfig Inheritance object TilemapCollisionConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ApplyTileFriction Whether to apply tile friction to entities. public bool ApplyTileFriction { get; set; } Property Value bool EnablePlatformCollision Whether to handle platform (one-way) collision. public bool EnablePlatformCollision { get; set; } Property Value bool PublishCollisionEvents Whether to publish collision events. public bool PublishCollisionEvents { get; set; } Property Value bool"
  },
  "api/Kobold.Extensions.Tilemaps.TilemapCollisionSystem.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TilemapCollisionSystem.html",
    "title": "Class TilemapCollisionSystem | Kobold Game Framework",
    "summary": "Class TilemapCollisionSystem Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll System that handles collision detection between entities and tilemap tiles. Integrates with Kobold.Core's physics and collision systems. public class TilemapCollisionSystem : ISystem Inheritance object TilemapCollisionSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TilemapCollisionSystem(World, EventBus?, TilemapCollisionConfig?) public TilemapCollisionSystem(World world, EventBus? eventBus = null, TilemapCollisionConfig? config = null) Parameters world World eventBus EventBus config TilemapCollisionConfig Methods IsPositionSolid(Vector2, TileMap, TileSet, Vector2) Checks if a specific world position collides with any solid tile. public bool IsPositionSolid(Vector2 worldPosition, TileMap tileMap, TileSet tileSet, Vector2 tilemapOffset) Parameters worldPosition Vector2 tileMap TileMap tileSet TileSet tilemapOffset Vector2 Returns bool Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Extensions.Tilemaps.TilemapComponent.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TilemapComponent.html",
    "title": "Struct TilemapComponent | Kobold Game Framework",
    "summary": "Struct TilemapComponent Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll ECS component that attaches a tilemap to an entity. Used with TilemapSystem for rendering and collision. public struct TilemapComponent Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors TilemapComponent(TileMap, TileSet) Creates a new tilemap component. public TilemapComponent(TileMap tileMap, TileSet tileSet) Parameters tileMap TileMap The tilemap tileSet TileSet The tileset Properties EnableCollision Whether to generate collision for solid tiles. public bool EnableCollision { readonly get; set; } Property Value bool Opacity Opacity for rendering (0.0 = transparent, 1.0 = opaque). public float Opacity { readonly get; set; } Property Value float RenderLayer Render layer priority (higher = rendered on top). public int RenderLayer { readonly get; set; } Property Value int TileMap The tilemap data (tile layout). public TileMap TileMap { readonly get; set; } Property Value TileMap TileSet The tileset (visual and property data for tiles). public TileSet TileSet { readonly get; set; } Property Value TileSet Visible Whether this tilemap is currently visible. public bool Visible { readonly get; set; } Property Value bool"
  },
  "api/Kobold.Extensions.Tilemaps.TilemapSystem.html": {
    "href": "api/Kobold.Extensions.Tilemaps.TilemapSystem.html",
    "title": "Class TilemapSystem | Kobold Game Framework",
    "summary": "Class TilemapSystem Namespace Kobold.Extensions.Tilemaps Assembly Kobold.Extensions.dll System that manages tilemap updates and animated tiles. Rendering is handled by platform-specific renderers that query TilemapComponent. public class TilemapSystem : ISystem Inheritance object TilemapSystem Implements ISystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TilemapSystem(World) public TilemapSystem(World world) Parameters world World Methods GetVisibleTiles(TileMap, int, float, float, int, int) Gets all visible tiles for a tilemap at a given layer within the camera viewport. Used by renderers to efficiently draw only visible tiles. public static List<(int x, int y, int tileId)> GetVisibleTiles(TileMap tileMap, int layer, float cameraX, float cameraY, int viewportWidth, int viewportHeight) Parameters tileMap TileMap The tilemap layer int Layer to query cameraX float Camera X position in world space cameraY float Camera Y position in world space viewportWidth int Viewport width in pixels viewportHeight int Viewport height in pixels Returns List<(int x, int y, int tileId)> List of visible tiles with their positions IsTilemapVisible(Entity) Helper method to check if a tilemap entity exists and is visible. public bool IsTilemapVisible(Entity entity) Parameters entity Entity Returns bool SetTilemapOpacity(Entity, float) Sets the opacity of a tilemap. public void SetTilemapOpacity(Entity entity, float opacity) Parameters entity Entity opacity float SetTilemapVisibility(Entity, bool) Sets the visibility of a tilemap. public void SetTilemapVisibility(Entity entity, bool visible) Parameters entity Entity visible bool Update(float) public void Update(float deltaTime) Parameters deltaTime float"
  },
  "api/Kobold.Extensions.Tilemaps.html": {
    "href": "api/Kobold.Extensions.Tilemaps.html",
    "title": "Namespace Kobold.Extensions.Tilemaps | Kobold Game Framework",
    "summary": "Namespace Kobold.Extensions.Tilemaps Classes TileDamageEvent Event published when an entity takes damage from a tile. TileMap Represents a grid-based tilemap with support for multiple layers. TileSet Represents a collection of tiles with their properties. Maps tile IDs to their visual and gameplay properties. TileTriggerEvent Event published when an entity triggers a tile. TilemapCollisionConfig Configuration for tilemap collision system. TilemapCollisionSystem System that handles collision detection between entities and tilemap tiles. Integrates with Kobold.Core's physics and collision systems. TilemapSystem System that manages tilemap updates and animated tiles. Rendering is handled by platform-specific renderers that query TilemapComponent. Structs TileProperties Properties associated with a tile. TilemapComponent ECS component that attaches a tilemap to an entity. Used with TilemapSystem for rendering and collision. Enums TileCollisionLayer Collision layers for tiles."
  },
  "api/Kobold.Monogame.MonoGameFileContentLoader.html": {
    "href": "api/Kobold.Monogame.MonoGameFileContentLoader.html",
    "title": "Class MonoGameFileContentLoader | Kobold Game Framework",
    "summary": "Class MonoGameFileContentLoader Namespace Kobold.Monogame Assembly Kobold.Monogame.dll MonoGame implementation of content loading that loads raw files directly from the file system. Loads PNG textures at runtime using Texture2D.FromStream, bypassing the MonoGame Content Pipeline. public class MonoGameFileContentLoader : IContentLoader Inheritance object MonoGameFileContentLoader Implements IContentLoader Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MonoGameFileContentLoader(GraphicsDevice, string) public MonoGameFileContentLoader(GraphicsDevice graphicsDevice, string contentRoot = \"Content\") Parameters graphicsDevice GraphicsDevice contentRoot string Properties ContentRoot Root directory for content files public string ContentRoot { get; } Property Value string Methods LoadTexture(string) Load a texture from a file path public ITexture LoadTexture(string path) Parameters path string Path to the texture file (relative to content directory) Returns ITexture The loaded texture TextureExists(string) Check if a texture file exists public bool TextureExists(string path) Parameters path string Path to check Returns bool True if the file exists"
  },
  "api/Kobold.Monogame.MonoGameHost.html": {
    "href": "api/Kobold.Monogame.MonoGameHost.html",
    "title": "Class MonoGameHost | Kobold Game Framework",
    "summary": "Class MonoGameHost Namespace Kobold.Monogame Assembly Kobold.Monogame.dll public class MonoGameHost : Game, IDisposable Inheritance object Game MonoGameHost Implements IDisposable Inherited Members Game.Dispose() Game.Dispose(bool) Game.Exit() Game.ResetElapsedTime() Game.SuppressDraw() Game.RunOneFrame() Game.Run() Game.Run(GameRunBehavior) Game.Tick() Game.BeginDraw() Game.EndDraw() Game.BeginRun() Game.EndRun() Game.Initialize() Game.OnExiting(object, ExitingEventArgs) Game.OnActivated(object, EventArgs) Game.OnDeactivated(object, EventArgs) Game.LaunchParameters Game.Components Game.InactiveSleepTime Game.MaxElapsedTime Game.IsActive Game.IsMouseVisible Game.TargetElapsedTime Game.IsFixedTimeStep Game.Services Game.Content Game.GraphicsDevice Game.Window Game.Activated Game.Deactivated Game.Disposed Game.Exiting object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MonoGameHost(IGameEngine, GameConfig?) public MonoGameHost(IGameEngine gameEngine, GameConfig? config = null) Parameters gameEngine IGameEngine config GameConfig Methods Draw(GameTime) Called when the game should draw a frame. Draws the Microsoft.Xna.Framework.DrawableGameComponent instances attached to this game. Override this to render your game. protected override void Draw(GameTime gameTime) Parameters gameTime GameTime A Microsoft.Xna.Framework.GameTime instance containing the elapsed time since the last call to Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) and the total time elapsed since the game started. LoadContent() Override this to load graphical resources required by the game. protected override void LoadContent() UnloadContent() Override this to unload graphical resources loaded by the game. protected override void UnloadContent() Update(GameTime) Called when the game should update. Updates the Microsoft.Xna.Framework.GameComponent instances attached to this game. Override this to update your game. protected override void Update(GameTime gameTime) Parameters gameTime GameTime The elapsed time since the last call to Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)."
  },
  "api/Kobold.Monogame.MonoGameInputManager.html": {
    "href": "api/Kobold.Monogame.MonoGameInputManager.html",
    "title": "Class MonoGameInputManager | Kobold Game Framework",
    "summary": "Class MonoGameInputManager Namespace Kobold.Monogame Assembly Kobold.Monogame.dll public class MonoGameInputManager : IInputManager Inheritance object MonoGameInputManager Implements IInputManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetMousePosition() public Vector2 GetMousePosition() Returns Vector2 IsKeyDown(KeyCode) public bool IsKeyDown(KeyCode key) Parameters key KeyCode Returns bool IsKeyPressed(KeyCode) public bool IsKeyPressed(KeyCode key) Parameters key KeyCode Returns bool IsKeyUp(KeyCode) public bool IsKeyUp(KeyCode key) Parameters key KeyCode Returns bool IsMouseButtonPressed(MouseButton) public bool IsMouseButtonPressed(MouseButton button) Parameters button MouseButton Returns bool Update() public void Update()"
  },
  "api/Kobold.Monogame.MonoGameRenderer.html": {
    "href": "api/Kobold.Monogame.MonoGameRenderer.html",
    "title": "Class MonoGameRenderer | Kobold Game Framework",
    "summary": "Class MonoGameRenderer Namespace Kobold.Monogame Assembly Kobold.Monogame.dll public class MonoGameRenderer : IRenderer Inheritance object MonoGameRenderer Implements IRenderer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MonoGameRenderer(GraphicsDevice, SpriteBatch, SpriteFont) public MonoGameRenderer(GraphicsDevice graphicsDevice, SpriteBatch spriteBatch, SpriteFont defaultFont) Parameters graphicsDevice GraphicsDevice spriteBatch SpriteBatch defaultFont SpriteFont Methods Begin() public void Begin() DrawLine(Vector2, Vector2, Color, float) public void DrawLine(Vector2 start, Vector2 end, Color color, float thickness = 1) Parameters start Vector2 end Vector2 color Color thickness float DrawRectangle(Vector2, Vector2, Color) public void DrawRectangle(Vector2 position, Vector2 size, Color color) Parameters position Vector2 size Vector2 color Color DrawSprite(ITexture, Vector2, Rectangle, Vector2, float, Color) public void DrawSprite(ITexture texture, Vector2 position, Rectangle sourceRect, Vector2 scale, float rotation, Color tint) Parameters texture ITexture position Vector2 sourceRect Rectangle scale Vector2 rotation float tint Color DrawText(string, Vector2, Color, float) public void DrawText(string text, Vector2 position, Color color, float fontSize = 16) Parameters text string position Vector2 color Color fontSize float DrawTexture(ITexture, Vector2, Vector2) public void DrawTexture(ITexture texture, Vector2 position, Vector2 scale = default) Parameters texture ITexture position Vector2 scale Vector2 DrawTriangle(Vector2[], Vector2, float, Color) public void DrawTriangle(Vector2[] points, Vector2 position, float rotation, Color color) Parameters points Vector2[] position Vector2 rotation float color Color DrawTriangleFilled(Vector2[], Vector2, float, Color) public void DrawTriangleFilled(Vector2[] points, Vector2 position, float rotation, Color color) Parameters points Vector2[] position Vector2 rotation float color Color End() public void End() ToXnaColor(Color) public static Color ToXnaColor(Color color) Parameters color Color Returns Color"
  },
  "api/Kobold.Monogame.MonoGameTexture.html": {
    "href": "api/Kobold.Monogame.MonoGameTexture.html",
    "title": "Class MonoGameTexture | Kobold Game Framework",
    "summary": "Class MonoGameTexture Namespace Kobold.Monogame Assembly Kobold.Monogame.dll public class MonoGameTexture : ITexture Inheritance object MonoGameTexture Implements ITexture Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MonoGameTexture(Texture2D) public MonoGameTexture(Texture2D texture) Parameters texture Texture2D Properties Height public int Height { get; } Property Value int Texture public Texture2D Texture { get; } Property Value Texture2D Width public int Width { get; } Property Value int"
  },
  "api/Kobold.Monogame.PixelFont.html": {
    "href": "api/Kobold.Monogame.PixelFont.html",
    "title": "Class PixelFont | Kobold Game Framework",
    "summary": "Class PixelFont Namespace Kobold.Monogame Assembly Kobold.Monogame.dll public static class PixelFont Inheritance object PixelFont Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DrawText(IRenderer, string, Vector2, Color, float) public static void DrawText(IRenderer renderer, string text, Vector2 position, Color color, float fontSize = 16) Parameters renderer IRenderer text string position Vector2 color Color fontSize float MeasureText(string, float) public static Vector2 MeasureText(string text, float fontSize = 16) Parameters text string fontSize float Returns Vector2"
  },
  "api/Kobold.Monogame.html": {
    "href": "api/Kobold.Monogame.html",
    "title": "Namespace Kobold.Monogame | Kobold Game Framework",
    "summary": "Namespace Kobold.Monogame Classes MonoGameFileContentLoader MonoGame implementation of content loading that loads raw files directly from the file system. Loads PNG textures at runtime using Texture2D.FromStream, bypassing the MonoGame Content Pipeline. MonoGameHost MonoGameInputManager MonoGameRenderer MonoGameTexture PixelFont"
  },
  "api/SpriteSheetEditor.SpriteSheetEditorGame.html": {
    "href": "api/SpriteSheetEditor.SpriteSheetEditorGame.html",
    "title": "Class SpriteSheetEditorGame | Kobold Game Framework",
    "summary": "Class SpriteSheetEditorGame Namespace SpriteSheetEditor Assembly SpriteSheetEditor.dll public class SpriteSheetEditorGame : Game, IDisposable Inheritance object Game SpriteSheetEditorGame Implements IDisposable Inherited Members Game.Dispose() Game.Dispose(bool) Game.Exit() Game.ResetElapsedTime() Game.SuppressDraw() Game.RunOneFrame() Game.Run() Game.Run(GameRunBehavior) Game.Tick() Game.BeginDraw() Game.EndDraw() Game.BeginRun() Game.EndRun() Game.UnloadContent() Game.OnExiting(object, ExitingEventArgs) Game.OnActivated(object, EventArgs) Game.OnDeactivated(object, EventArgs) Game.LaunchParameters Game.Components Game.InactiveSleepTime Game.MaxElapsedTime Game.IsActive Game.IsMouseVisible Game.TargetElapsedTime Game.IsFixedTimeStep Game.Services Game.Content Game.GraphicsDevice Game.Window Game.Activated Game.Deactivated Game.Disposed Game.Exiting object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SpriteSheetEditorGame() public SpriteSheetEditorGame() Methods Draw(GameTime) Called when the game should draw a frame. Draws the Microsoft.Xna.Framework.DrawableGameComponent instances attached to this game. Override this to render your game. protected override void Draw(GameTime gameTime) Parameters gameTime GameTime A Microsoft.Xna.Framework.GameTime instance containing the elapsed time since the last call to Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) and the total time elapsed since the game started. Initialize() Override this to initialize the game and load any needed non-graphical resources. Initializes attached Microsoft.Xna.Framework.GameComponent instances and calls Microsoft.Xna.Framework.Game.LoadContent(). protected override void Initialize() LoadContent() Override this to load graphical resources required by the game. protected override void LoadContent() Update(GameTime) Called when the game should update. Updates the Microsoft.Xna.Framework.GameComponent instances attached to this game. Override this to update your game. protected override void Update(GameTime gameTime) Parameters gameTime GameTime The elapsed time since the last call to Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)."
  },
  "api/SpriteSheetEditor.html": {
    "href": "api/SpriteSheetEditor.html",
    "title": "Namespace SpriteSheetEditor | Kobold Game Framework",
    "summary": "Namespace SpriteSheetEditor Classes SpriteSheetEditorGame"
  },
  "index.html": {
    "href": "index.html",
    "title": "Kobold Game Framework | Kobold Game Framework",
    "summary": "Kobold Game Framework A lightweight, platform-agnostic ECS (Entity Component System) game framework for .NET. Quick Links Getting Started Core Concepts API Reference What is Kobold? Kobold is a modular game framework built on the Arch ECS library, designed to be simple, flexible, and platform-agnostic. It provides: Core Framework - Platform-agnostic game engine base MonoGame Integration - Full MonoGame rendering and input support Extension Libraries - Tilemaps, procedural generation, and more Development Tools - Sprite sheet editor and experimentation tools Features Entity Component System architecture using Arch Flexible rendering abstraction Input management system Physics and collision detection Event bus for game events Asset management Tilemap support Procedural generation tools Getting Started // Create a simple game public class MyGame : GameEngineBase { public override void Initialize() { base.Initialize(); // Your initialization code } public override void Update(float deltaTime) { base.Update(deltaTime); // Your update logic } public override void Render() { base.Render(); // Rendering handled by systems } } Check out the Getting Started Guide for more details. License Copyright © 2025 Kobold Game Framework"
  }
}