<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Entity Component System (ECS) Framework | Kobold Game Framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Entity Component System (ECS) Framework | Kobold Game Framework ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/toricook/kobold/blob/docs/Kobold.Documentation/docs/explainers/entity-component-system.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="entity-component-system-ecs-framework">Entity Component System (ECS) Framework</h1>

<h2 id="what-is-it">What is it?</h2>
<p>There are probably a lot of explainers out there for ECS that are written better than this doc here. For me, the easiest way to understand ECS is by comparing it to the more well known Object Oriented Programming (OOP). Say you were making a dungeon crawler using OOP. You might start off by creating a class for your player character. It could look something like this:</p>
<pre><code class="lang-csharp">
class Player
{
    Vector2 position;
    Sprite sprite;
    int health;

    void Update() { /* update logic */ }
    void Render() { /* render logic */ }
}
</code></pre>
<p>But then when you go to make your enemies, you realize they share a lot of qualities with the player -- they also have health, a position, and a sprite. So perhaps instead you go and make a base class for both of them like this:</p>
<pre><code class="lang-csharp">
abstract class Actor
{
    Vector2 position;
    Sprite sprite;
    int health;

    void Update() { /* update logic */ }
    void Render() { /* render logic */ }
}
</code></pre>
<p>Then a player is just an implementation of an Actor, maybe with some additional logic to do input handling so that the real life player can control their movements. And an enemy is also an Actor, but it has some kind of AI movement logic attached. So far, so good. But then what if you want to make another kind of enemy that's invulnerable, so it has no need for a health field? Or what about one that's invisible, so it doesn't have a sprite or need a Render() method? Well, maybe an Actor shouldn't actually be renderable or have health by default -- these are separate concerns, after all. Maybe we need a new abstract base class for an Actor that can take damage, or an Actor that is also visible, or an Actor that is both. You can see how we can quickly end up with a ton of class hierarchies that are almost-but-not-quite the same and we would end up duplicating a lot of code. You may have heard of the principle of &quot;Composition over Inheritance&quot;, which helps get around issues like this. Instead of an &quot;is-a&quot; relationship (a player IS An actor), you create &quot;has-a&quot; relationships (a player HAS A renderable component and HAS A health component). ECS follows this principle.</p>
<p>But it's also not JUST a way to get composition over inheritance. ECS also uses the principle of Data Oriented Design. To understand what this priciple is, consider our player and all of our enemies in our dungeon crawler. Let's say we are also using a velocity field on each one in order to calculate whether this entity should move or not. In each frame, we have to iterate over all the entities, check their velocity, then multiply it by the time and update thier position. Then once we have the new positions, we need to iterate over all of the entities again and render them to the screen using their sprite component. But the inefficiency here comes from the bigass data object that we are iterating over each time. The system responsible for moving each entity doesn't care about the sprite, and the system responsibile for rendering (probably) doesn't care about the velocity. Yet they both need to load ALL of that data about the entity into memory just to do something with one little piece of it. This is the problem that Data Oriented Programming attempts to solve.</p>
<p>So now we are ready to learn what ECS is. It stands for Entity Component System (though I think it's a bit clearer to write it like Entity, Component, System to make it clear that these are the 3 elements of the framework) -- all words that I used in the above explanation to help motivate the defition. In ECS, each &quot;thing&quot; that exists in your game is not an implementation of a class but an <em>entity</em>, which is literally just a unique ID. The things that make each entity behave in a certain way are called <em>components</em> -- the are the &quot;has-a&quot; objects like sprites and health. But components are always just data -- they are structs (value types). The components are acted on by <em>systems</em>, where each system needs access only to a certain type of component to do its job. The &quot;magic&quot; in the performance comes from the way that systems can access an array of just the components they need and then iterate over and act on those components without caring about the entities that those components are attached to.</p>
<p>With ECS, we would write the code from the dungeon crawler example like this:</p>
<pre><code class="lang-csharp">
struct Position
{
    float x;
    float y;
}
</code></pre>
<pre><code class="lang-csharp">
struct Health
{
    float value;
}
</code></pre>
<pre><code class="lang-csharp">
struct Sprite
{
    ITexture texture;
}
</code></pre>
<p>and then create each entity by just creating some object that has a unique ID and the right collection of components. But before I can get into <em>how</em> to create the entities, and how to create the systems that actually do things with these components, I need to give a quick intro to Arch.</p>
<h2 id="quick-arch-intro">Quick Arch Intro</h2>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/toricook/kobold/blob/docs/Kobold.Documentation/docs/explainers/entity-component-system.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright Â© 2025 Kobold Game Framework
        </div>
      </div>
    </footer>
  </body>
</html>
